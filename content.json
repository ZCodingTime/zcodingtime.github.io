{"meta":{"title":"Z 空间","subtitle":"世事洞明皆学问，人情练达即文章。","description":"喜欢 Python 的靠 Java 和 JavaScript 吃饭的中年人，不谢顶。","author":"zucchiniy","url":"https://www.zucchiniy.cn/hexo-blog","root":"/hexo-blog/"},"pages":[{"title":"关于","date":"2020-01-07T09:42:18.404Z","updated":"2020-01-07T09:42:18.404Z","comments":true,"path":"about/index.html","permalink":"https://www.zucchiniy.cn/hexo-blog/about/index.html","excerpt":"","text":"个人信息 Dylan Yang 邮箱：banshiliuli1990@sina.com 技术博客：https://www.zucchiniy.cn github：https://github.com/zucchiniy Emacs 用户，喜欢学习，喜欢折腾 重度手残，五笔用户 学习 Python 中希望能成为 Pythonista 。 技能清单以下内容评级按照 简历中的技术水平 进行评定 熟悉 Linux 系统 熟悉 Mac、Linux 下的环境配置 熟悉 MySQL 了解 Java、C、C++ 熟练使用 Vim、Emacs 熟悉 Python 并努力上升到熟练中"},{"title":"","date":"2019-12-23T07:23:12.167Z","updated":"2019-12-23T07:23:12.167Z","comments":true,"path":"projects/index.html","permalink":"https://www.zucchiniy.cn/hexo-blog/projects/index.html","excerpt":"","text":""},{"title":"","date":"2020-01-07T09:41:32.704Z","updated":"2020-01-07T09:41:32.704Z","comments":true,"path":"thematics/index.html","permalink":"https://www.zucchiniy.cn/hexo-blog/thematics/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-23T07:16:54.303Z","updated":"2019-12-23T07:16:54.303Z","comments":true,"path":"blog/tags/index.html","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-12-23T07:16:06.278Z","updated":"2019-12-23T07:16:06.278Z","comments":true,"path":"blog/categories/index.html","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"利用 find 和 grep 联合查找文件","slug":"工具环境/linux/find-files-on-linux","date":"2020-01-06T16:00:00.000Z","updated":"2020-01-07T02:23:31.806Z","comments":true,"path":"2020/01/07/工具环境/linux/find-files-on-linux/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2020/01/07/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/linux/find-files-on-linux/","excerpt":"","text":"Linux 下 使用 find 命令查找文件。 常用组合 查找所有 .h 文件 1find &lt;pathname&gt; -name \"*.h\" 查找所有 .h 文件中的含有 helloworld 字符串的文件 12find &lt;pathname&gt; -name \"*.h\" -exec grep -in \"helloworld\" &#123;&#125; \\;find &lt;pathname&gt; -name \"*.h\" | xargs grep -in \"helloworld\" 第一个命令中的 {} 是指的 find &lt;pathname&gt; -name &quot;*.h&quot; 的结果，也是就说，第一个命令中 grep 是在 find 查到的结果中进行二次筛选操作。而后面的 \\; 则是语句的结束标识，也就是转义的 ; 。 第二个命令则是使用的管道。 查找所有 .h 和 .c 文件中的含有 helloworld 字符串的文件 1find &lt;pathname&gt; /( -name \"*.h\" -or -name \"*.c\" /) -exec grep -in \"helloworld\" &#123;&#125; \\; 查找非备份文件中的含有 helloworld 字符串的文件 1find &lt;pathname&gt; /( -not -name \"*~\" /) -exec grep -in \"helloworld\" &#123;&#125; \\; 为查找路径，默认为当前路径。带 -exec 参数时必须以 ; 结尾，否则会提示 『find: 遗漏 -exec 的参数』。 使用 find 和 xargsfind &lt;pathname&gt; -options [-print -exec -ok] -optinos -name:按照文件名查找12find ~ -name “*.txt” -printfind ~ -name “[a-z][0-9].txt -print -perm:按照权限查找文件123find ~ -perm 755 -print #查找权限为755的文件find ~ -perm 007 -print #查找o位置上具有7权限的文件find ~ -perm 4000 -print #查找具有suid的文件 -prune不在当前目录下查找 -user 和 -nouser12find ~ -user zhao -print #查找文件属主是zhao的文件find ~ -nouser -print #查找文件属主已经被删除的文件 -group和－nogroup1find ~ -group zhao -print #查找文件群组是zhao的文件 按照时间123find ~ -mtime -5 -print #文件更改时间在5天内的文件find ~ -mtime +3 -print #文件更改时间在3天前的文件find ~ -newer file1 -print #查找比文件file1新的文件 按照类型查找1find ~ -type d -print #查找所有目录 按照大小1find ~ -size +1000000C -print #查找文件大小大于1000000字节(1M)的文件 查找位于本文件系统里面的文件1find / -name \"*.txt\" -mount -print -exec , -ok : find 命令对于匹配文件执行该参数所给出 shell 命令，相应命令形式为: &#39;command&#39; {} \\;-ok 在执行命令前要确认 123find ~ -type f -exec ls -l &#123;&#125; \\;find / -name “*.log” -mtime +5 -ok rm &#123;&#125; \\;find . -name core -exec rm &#123;&#125; \\; 使用 -x dev 参数防止 find 搜索其他分区find . -size 0 -exec rm {} \\; 删除尺寸为０的文件 xargs 与-exec 功能类似 123find ~ -type f | xargs ls -lfind / -name “*.log” -type f -print| xargs grep -i DB0find . -type f |xargs grep -i “Mary” 在所有文件中检索字符串 Mary ls *~ |xargs rm -rf 删除所有以~结尾的文件 过滤 svn 文件夹 使用管道进行双层“过滤”，其中第二次 grep 使用了 -v 选项，即逆向匹配，打印出不匹配的行 grep -r &#39;function_name&#39; * | grep -v &#39;.svn&#39; 或者更简单一些，直接使用 --exclude-dir 选项，即指定排除目录，注意 svn 前的 \\. 1grep -r --exclude-dir=\\.svn 'function_name' * 多个过滤条件或操作123grep -E '123|abc' filename # 找出文件（filename）中包含123或者包含abc的行egrep '123|abc' filename # 用egrep同样可以实现awk '/123|abc/' filename # awk 的实现方式 与操作grep pattern1 files | grep pattern2 显示既匹配 pattern1 又匹配 pattern2 的行。 其他操作12345grep -i pattern files #不区分大小写地搜索。默认情况区分大小写，grep -l pattern files #只列出匹配的文件名，grep -L pattern files #列出不匹配的文件名，grep -w pattern files #只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），grep -C number pattern files #匹配的上下文分别显示[number]行， find 过滤 svn 文件夹find -type f ! -path &#39;*/.svn/*&#39; find 查找大文件1find . -type f -size +800M type 类型 : b 块设备， d 目录， c 字符设备文档， p 管道文档， l 符号链接文档， f 普通文档 name 文件名 : 支持通配符 size 文件大小 : + 表示大于， - 表示小于，支持 k/M/G 的单位 1find . -type f -size +800M | xargs ls -lh 这里的 xargs 是把管理参数切分成多个部分，可以将命令进行组合 du 查找大目录123du -h --max-depth=1du -hm --max-depth=2 | sort -ndu -hm --max-depth=2 | sort -nr | head -12","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"find","slug":"find","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/find/"},{"name":"grep","slug":"grep","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/grep/"},{"name":"du","slug":"du","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/du/"}]},{"title":"搭建个人博客","slug":"工具环境/build-blog-with-hexo","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-06T02:53:11.925Z","comments":true,"path":"2020/01/05/工具环境/build-blog-with-hexo/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2020/01/05/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/build-blog-with-hexo/","excerpt":"","text":"我们无法选择生活的样子，但我们可以记下来。 博客的开始其实，一切都是为了更好的装逼。好吧，我着相了。 最开始想做一个自己博客，主要是因为看到了很多人都有，觉得自己没有太 Low 了。于是申请了 CSDN 的用户，但是太丑了，于是又申请了博客园，感觉这些都不是我想要的，而做为一个 Emacser 不使用 Github 搭建一个自己的博客，感觉就已经落伍了。 于是就有这最初的一个，相当简陋的利用 Emacs 的 Org-mode 搭建的博客，后来看了 Org-page 这个包，但是，我配置不好啊！为什么为什么！ 最后，从 Hugo 和 Hexo 之间，我选择了 Hexo，虽然 Hugo 在 Windows 上使用起来更方便，但是我还是觉得 Hexo 更适合我。 利用 Hexo 的坑 有些插件需要翻墙，有些不用，我也不记得哪个用哪个不用了，实在不行可以使用淘宝的npm 源进行安装。 环境配置好之后，最好更新一下模板，把一些常用的内容写到 Hexo的模板里，这样在后续的使用中，可以快速的增加标签、分类和简介等内容。 学习 Markdown , 这个并不是一个坑，而是一个忠告，作为一个常年游荡在GitHub 的好同志来说，但是对于一个 Emacser 来说，我更喜欢 Org-mode，但是 Org-mode 并不能直接用来发布 Hexo博客，有些人会说可以利用一些工具，但是与其增加一些工具，不如学习一下Markdown, 这根本用不了几分钟，虽然 Org-mode很强大（忍不住安利一波），但是 Markdown作为一个大众的标记语言，简单的语法还是需要我们掌握的。 记住常用的命令 hexo new markdown_file 新建文章 hexo new page html_file 新建页面 hexo generate 生成静态页面到 public 目录 hexo server 开启预览访问端口，4000， Ctrl+c 关闭 server hexo deploy 将 .deploy 目录部署到 GitHub 这里需要配置 deploy 的项目地址并安装了 hexo-deployer-git 插件，才能使用这个功能 最后一个坑，挑选一个合适的主题，好吧，我选择了很久——大概四天吧，可能很多人能非常快的决定，但是对于我来说，把所有好看的主题都看一遍，才是我想做的事，最后我选择了 Next 主题，简单美观，还有非常齐全的配置说明 部署使用的命令有三个 hexo clean / hexo generate / hexo deploy，这三个命令之后，就可以登录你的静态博客页面去查看了。 博客的生活我很喜欢调试自己的博客，但是写博客就不是那么喜欢了，但是我希望能养成一个定期写博客的习惯。 所以，我需要博客，主要是用来装…咳，主要是用来记录我们的生活、工作的内容，这样在下次使用的时候，就能更好的做到了。 Hexo 相关安装在几次试验之后，Node.js 环境还是使用 nvm管理比较好用，下载的时候可以使用 npm --registry=https://registry.npm.taobao.org install 进行安装下面的模块。 12345678910npm install -g hexo-clinpm install hexo-deployer-git --savenpm install hexo-generator-search --savenpm install hexo-generator-feed --savenpm install -g ternnpm install -g js-beautifynpm install -g jshintnpm install -g js-yamlnpm install hexo-renderer-jade --savenpm install hexo-renderer-sass --save hugoHugo 是由 Go 语言实现的一个 Static Site Generator 工具，特点就是快，而且默认是支持 Org mode 这种文本的。 虽然对于 hexo 而言少了许多好看的主题，但是对于 Org mode 的默认支持让我有了决心一用的冲动。 在使用了一段时间之后，发现这个工具完美的解决了我所有的问题，并能让我专心于博客写作本身而不是工具，虽然有一些不方便，但最后还是决定继续使用，而且要减少对工具本身的使用，而加强写作本身。 在长时间的使用之后，发现 Hugo 对 Org mode 的支持也比较一般，对于一些比较好用的特性，功能都不支持，最好的方案还是从 Org 转成 Markdown ，所以在最终使用 ox-hugo 工具配合 Hugo 使用，然后通过 capture 功能直接生成对应的博客文章，方便快捷。 ox-hugo 配置使用 ox-hugo 主要需要配置两个内容，一是将 ox-hugo 增加到配置中，然后是在 启动 org-capture 的时候，增加一个新的选项，可以将自动新增一篇文章。 1234567891011121314151617181920212223242526(use-package ox-hugo :after ox)(with-eval-after-load &#39;org-capture (defun org-hugo-new-subtree-post-capture-template () &quot;Return &#96;org-capture&#39; template string for new Hugo post.&quot; (let* ((date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time))) (title (read-from-minibuffer &quot;Post Title: &quot;)) (file-name (read-from-minibuffer &quot;File Name: &quot;)) (fname (org-hugo-slug file-name))) (mapconcat #&#39;identity &#96;( ,(concat &quot;* TODO &quot; title) &quot;:PROPERTIES:&quot; ,(concat &quot;:EXPORT_FILE_NAME: &quot; fname) ,(concat &quot;:EXPORT_DATE: &quot; date) &quot;:END:&quot; &quot;%?\\n&quot;) &quot;\\n&quot;))) (add-to-list &#39;org-capture-templates &#39;(&quot;h&quot; &quot;Hugo post&quot; entry (file &quot;~&#x2F;workspace&#x2F;blog&#x2F;hugo-posts.org&quot;) (function org-hugo-new-subtree-post-capture-template)))) 在这里，我是将所有的文章写到对应的一个文件中，然后将文件中的所有内容生成到对应的 hugo 文件夹中。 文件头配置如下： 123#+HUGO_BASE_DIR: ~&#x2F;workspace&#x2F;blog&#x2F;content&#x2F;#+SEQ_TODO: TODO DRAFT DONE#+OPTIONS: ^:&#123;&#125; 然后在这个文件中使用导出的快捷键，就可以看到对应的选项了，将 org-export-dispatch 命令绑定到自己的快捷键上就可以看到对应的输出命令。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"hexo","slug":"工具环境/hexo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/hexo/"},{"name":"hugo","slug":"hugo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/hugo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/GitHub-Pages/"}]},{"title":"读书/观影清单","slug":"生活总结/book-movie-list","date":"2020-01-03T16:00:00.000Z","updated":"2020-01-06T06:22:03.305Z","comments":true,"path":"2020/01/04/生活总结/book-movie-list/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2020/01/04/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/book-movie-list/","excerpt":"","text":"2020 年读书观影清单东野圭吾小说阅读非系列小说 白夜行 幻夜 解忧杂货店 超杀人事件 彷徨之刃 秘密 流星之绊 时生 信 放学后 &lt;2019-12-06 Fri&gt; 单恋 虚无的十字架 宿命 杀人之门分身 导论13 绑架游戏 使命与魂的尽头 湖边杀人案 平等世界 爱情故事 四笑小说 怪笑小说 毒笑小说 黑笑小说 歪笑小说 滑雪场系列 疾风回旋曲 &lt;2017-11-24 Fri&gt; 2.0 风雪追击 加贺一郎系列 毕业 &lt;2019-12-14 Sat&gt; 沉睡的森林 &lt;2019-12-16 Mon&gt; 谁杀了她 &lt;2019-12-17 Tue&gt; 恶意 &lt;2019-12-18 Wed&gt; 我杀了他 &lt;2019-12-22 Sun&gt; 只差一个谎言 &lt;2019-12-29 Sun&gt; 红手指 &lt;2019-12-31 Tue&gt; 新参者 &lt;2020-01-02 Thu&gt; 麒麟之翼 &lt;2020-01-03 Fri&gt; 祈祷落幕时 &lt;2019-12-12 Thu&gt; 神探伽利略系列 侦探伽利略 &lt;2020-01-06 Mon&gt; 预知梦 嫌疑人 x 的献身 &lt;2019-12-09 Mon&gt; 圣女的救济 伽利略的苦恼 盛夏的方程式 虚像小丑 禁忌魔术 其它推理小说 罗杰疑案 东方快车谋杀案 无人生还 啤酒谋杀案 ABC 杀人案 福尔摩斯探案全集 消失的爱人 告白 逻辑王子的演绎 化工女王的逆袭 物理教师时空诡计 代上帝之手 无证之罪 坏小孩 长夜难明 络新妇之理 姑获鸟之夏 福尔摩斯探案集 占星术杀人魔法 死了七次的男人 一桩事先张扬的凶杀案 半落 别相信任何人 护士学院杀人事件 所罗门的伪证 达芬奇密码 金色梦乡 余生皆假期 铁鼠之槛 罗杰疑案 尼罗河上的惨案 十角馆事件 一朵桔梗花 夏与冬的奏鸣曲 异邦骑士 七个证人 电影 控方证人 消失的爱人 彗星来的那一夜 穆赫兰道 搏击俱乐部 东方快车谋杀案 致命ID 七宗罪 天使与魔鬼 &lt;2020-01-05 Sun&gt; 达芬奇密码 &lt;2020-01-05 Sun&gt; 连续剧 神探伽利略 &lt;2020-01-04 Sat&gt; 犯罪心理2 犯罪心理3 犯罪心理4 犯罪心理5 犯罪心理6 犯罪心理7 犯罪心理8 不死法医 劳拉之谜 大小谎言 Lie to me 神探夏洛克 布雷德利夫人探案 骇人命案事件簿 无妄之灾 我的恐怖妻子 2019 年读书观影清单小说 尸语者 无声的证词 十一根手指 清道夫 幸存者 偷窥者 天谴者 大唐狄公案 一 大唐狄公案 二 大唐狄公案 三 大唐狄公案 四 大唐狄公案 五 大唐狄公案 六 心理罪系列 电影 惊奇队长 复仇者联盟 4 惊声尖笑 1 惊声尖笑 2 惊声尖笑 3 惊声尖笑 4 x 战警：黑凤凰 黑衣人：全球追缉 蜘蛛侠：英雄远征 看不见的客人 深夜食堂 &lt;2019-10-04 Fri&gt; 大侦探皮卡丘 &lt;2019-10-05 Sat&gt; 超能陆战队 &lt;2019-10-06 Sun&gt; 沉默的证人 &lt;2019-10-10 Thu&gt; 连续剧 东宫 知否知否应是绿肥红瘦 犯罪心理1 无人生还 心理法医 专题电影记录漫威系列 《钢铁侠》 《钢铁侠》 《无敌浩克》 《钢铁侠2》 《雷神》 《美国队长》 《复仇者联盟》 《钢铁侠3》 《雷神2》 《美国队长2》 《银河护卫队》 《复仇者联盟2》 《蚊人》 《美国队长3》 《奇异博士》 《银河护卫队2》 《蜘蛛侠》 《雷神3》 《黑豹》 《复仇者联盟3》 《死待》 《死待2》 《蜘蛛侠-英雄归来》 『2017-9-15』 《复仇者联盟3:无限战争》『2018-5-13』 《蚁人2:黄蜂女现身》『2018-8-24』 《毒液:致命守护者》『2018-11-11』 《蜘蛛侠》 《蜘蛛侠2》 《蜘蛛侠3》 DC 影业 《正义联盟》『2017-11-22』 《海王》『2018-12-09』 其它 《神奇动物在哪里：格林德沃之罪》『2018-11-24』 《你的名字》『2017-11-20』 《银魂》『2017-9-1』 《疯狂动物城》 《看不见的客人》 『2017-9-17』 《天才枪手》 《环太平洋 雷霆再起》『2018-6-24』 《神探》『2018-5-25』 《古墓丽影 缘起之战》『2018-6-27』 《玛丽与魔女之花》 『2018-6-28』 《泄密者》『2018-7-19』 《唐人街探案2》『2018-2-22』 《无双》","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"},{"name":"年度清单","slug":"生活总结/年度清单","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/%E5%B9%B4%E5%BA%A6%E6%B8%85%E5%8D%95/"}],"tags":[{"name":"读书清单","slug":"读书清单","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E8%AF%BB%E4%B9%A6%E6%B8%85%E5%8D%95/"},{"name":"电影清单","slug":"电影清单","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E7%94%B5%E5%BD%B1%E6%B8%85%E5%8D%95/"},{"name":"电视清单","slug":"电视清单","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E7%94%B5%E8%A7%86%E6%B8%85%E5%8D%95/"}]},{"title":"Valine 评论使用报错 504","slug":"前端开发/valine-504-error","date":"2019-12-19T09:50:20.000Z","updated":"2020-01-06T02:48:59.675Z","comments":true,"path":"2019/12/19/前端开发/valine-504-error/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/12/19/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/valine-504-error/","excerpt":"","text":"最近准备重新配置一下 个人博客 ，由原来的 Hugo 改到 Hexo 来做。 评论系统也由之前的 disqus 改成现在的 valine 。 主题也使用了非常好看的 Material Design 的样式的 Material-x ，并在此之上进行修改。 完成初始的配置之后，做一下测试。 恩。。。报错了？！ 虽然报错，但是可以正确的显示对应的服务，查询了一下原因，发现是因为长时间未使用 LeanCode 的服务，导致文件上传域名无法访问了，需要在 设置-&gt;应用 Keys 下面，选择重启 文件上传域名 和 文件访问域名 的服务即可。 具体的位置如下：","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"hexo","slug":"前端开发/hexo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/hexo/"},{"name":"valine","slug":"valine","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/valine/"},{"name":"Code 504","slug":"Code-504","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/Code-504/"}]},{"title":"Python 转换 Markdown 方法","slug":"后台技术/python/python-convert-markdown-to-html","date":"2019-10-11T18:43:00.000Z","updated":"2020-01-06T02:50:59.071Z","comments":true,"path":"2019/10/12/后台技术/python/python-convert-markdown-to-html/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/10/12/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/python/python-convert-markdown-to-html/","excerpt":"","text":"昨天看书的时候，看到了作者留的一个练习，是将 Markdown 的文档转换成 HTML 的方法。类似的标记语言还有 RestruredText 和 Org Mode，但是貌似 Org 比较小众，暂没有。 在 Django 中进行转换有两个方案，一个是直接安装 markdown 的模块，pip install markdown ，这种方式是直接将 Markdown 渲染成 HTML ，但是在 Django 项目中需要使用模板进行渲染，会导致样式改变，所以需要增加 safe 到模板中，表示不需要转义。 代码块如下： 1234567891011121314151617# 在 view.py 里使用 markdown 进行渲染import markdowndef page(request, name): template = get_template('doc.html') docfile = get_template('doc/&#123;&#125;.md'.format(name)) content = docfile.render() html = template.render(&#123; 'docname' : name 'content' : markdown.markdown(content, extensions=[ 'markdown.extensions.extra', 'markdown.extensions.codehilite', 'markdown.extensions.tox', ]) &#125;) return HttpResponse(html) 123456&lt;!DOCTYPE&gt;&lt;html lang='en'&gt; &lt;body&gt; &#123;&#123; content | safe &#125;&#125; &lt;/body&gt;&lt;/html&gt; 另一个方案是使用 django.markdown-deux 进行渲染，首先在 INSTALL_APPS 中增加 markdown-deux , 然后模板里引用这个标签： 1234567&lt;!DOCTYPE&gt;&lt;html lang='en'&gt; &lt;body&gt; &#123;% load markdown-duex-tags %&#125; &#123;&#123; content | markdown &#125;&#125; &lt;/body&gt;&lt;/html&gt; 这样也可以将 Markdown 直接渲染成网页了。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"django","slug":"django","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/django/"},{"name":"markdown","slug":"markdown","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/markdown/"},{"name":"markdown-deux","slug":"markdown-deux","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/markdown-deux/"}]},{"title":"利用 Python 生成数据透视表","slug":"后台技术/python/python-process-excel","date":"2019-08-08T22:53:00.000Z","updated":"2020-01-06T02:51:14.916Z","comments":true,"path":"2019/08/09/后台技术/python/python-process-excel/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/08/09/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/python/python-process-excel/","excerpt":"简介 利用 read_excel() 的 usecols 参数来指定表的某一列，以方便排除不必要的干扰列 养成数据加载以后，使用 head() 进行预览的习惯 养成使用 shape() 及 info() 了解表格基本情况的习惯 利用 info() 方法查看数据中是否有空值，如果有空值的话，则可以使用 dropna() 方法将其移除。 需要掌握的主要有两个方法: DataFrame.insert() 方法，用来增加对应的列 DataFrame.pivot_table() 产生透视图，展示重要的数据","text":"简介 利用 read_excel() 的 usecols 参数来指定表的某一列，以方便排除不必要的干扰列 养成数据加载以后，使用 head() 进行预览的习惯 养成使用 shape() 及 info() 了解表格基本情况的习惯 利用 info() 方法查看数据中是否有空值，如果有空值的话，则可以使用 dropna() 方法将其移除。 需要掌握的主要有两个方法: DataFrame.insert() 方法，用来增加对应的列 DataFrame.pivot_table() 产生透视图，展示重要的数据 具体方法 DataFrame.insert(self, loc, column, value, allow_duplicates=False) loc : int 表示第几列；0 &lt;= loc &lt;= len(columns)column : string, number, or hashable object;给插入的列取名，如 column=’新的一列’value : int ，array，seriesallow_duplicates : bool 是否允许列名重复，选择 True 表示允许新的列名与已存在的列名重复。 DataFrame.pivot_table(self, values=None, index=None, columns=None, aggfunc=&#39;mean&#39;, fill_value=None, margins=False, dropna=True, margins_name=&#39;All&#39;, observed=False) values : 要进行透视展示的数据index : 需要重新进行展示成列，是原始数据中的某一个行columns : 要重新展示为行的内容，是原来的列或者是其它的属性，可以是列表aggfunc : 要进行统计的行，可以是 numpy.sum / numpy.mean 等，也可以按列进行统计 aggfunc={&#39;c1&#39; : numpy.mean, &#39;c2&#39; : numpy.sum}fill_value : 将缺失值替换的值，幽灵将 Nan 换成 0 : fill_value=0margins : bool, 增加行或者列的汇总信息dropna : bool ，是否要删除为空的信息margin_name : string , 默认为 all ，或者自定义一个名称 observed bool , True 显示分类中的数据，False 显示所有数据，默认为 False 示例代码1234567891011121314151617181920212223242526272829303132333435import pandas as pdfrom datetime import datetimedata = pd.read_excel(r'python_learning.xlsx', usecols=[1, 4, 6, 7, 8, 9, 10, 11, 12], sheet_name='sheetName')data = data[data['合同生效日'] &gt; datetime(2018, 12, 31)]# 按逻辑，将一组数据拆成三组data1 = data[[\"used\", \"loan amount\", \"company1\", \"percent1\"]]data2 = data[[\"used\", \"loan amount\", \"company2\", \"percent2\"]]data3 = data[[\"used\", \"loan amount\", \"company3\", \"percent3\"]]# 将三组内容，重新命名之后合成一个新表data1 = data1.rename(columns=&#123;\"company1\": \"company\", \"percent1\": \"percent\"&#125;)data2 = data2.rename(columns=&#123;\"company2\": \"company\", \"percent2\": \"percent\"&#125;)data3 = data3.rename(columns=&#123;\"company3\": \"company\", \"percent3\": \"percent\"&#125;)data4 = pd.concat([data1, data2, data3], ignore_index=True)# 将数据中的空值清除data4 = data4.dropna()# 插入新的数据# 1. insert() 方法data4.insert(2, \"devide percent\", data4[\"percent\"]/100)data4.insert(5, \"devide amount\", data4[\"loan amount\"]*data4[\"deivide percent\"]/10000, False)# 普通索引方式插入# data4[\"loan divide amount\"] = data4[\"load amount\"]*data4[\"deivide percent\"]/10000# 增加数据透视data5 = data4[['company', 'used', 'loan amount']]data6 = pd.pivot_table(data5, values=\"loan divide amount\", columns=\"used\", index=\"company\", aggfunc='sum', fill_value=0, observed=False).reset_index()print(data6.head())","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"透视表","slug":"透视表","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E9%80%8F%E8%A7%86%E8%A1%A8/"},{"name":"read_excel()","slug":"read-excel","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/read-excel/"}]},{"title":"简历中的水平","slug":"生活总结/knowledge-level-in-resume","date":"2019-08-04T17:40:00.000Z","updated":"2020-01-07T07:15:23.508Z","comments":true,"path":"2019/08/05/生活总结/knowledge-level-in-resume/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/08/05/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/knowledge-level-in-resume/","excerpt":"","text":"在写自己的简历的时候，有时候会有对自己的水平不清楚，查了一些资料，大概了解了一下相关的水平。 了解 : 知道，不会做，找个人带着可以帮点忙 熟悉 : 知道，能做 60%-80% 的工作。但碰到难题需要指导一下 熟练（掌握）: 95% 以上的相关工作进季可 独立完成 ，无需指导帮忙。且能在 工作技巧上指导 “了解”、“熟悉” 精通 : “熟练” 那 5% 解决不了的，“精通” 可以攻关完成。“精通”最主要的价值是可以 技术预研，能改革现有程序或者方法，解决新问题 。精通另一点价值是能解脱民 单一领域多层次问题 ，或 多领域单一层次问题 。 看了一些文章，很多招聘需求中都写着要精通某一技术，很多人说这个有点高了，但其实有可能这里的精通是指的熟练这一级别，毕竟 精通 可以说是达到了某一领域中的极限，很多工作并不需要这样的人，除非真的是非常重要的位置。而一般招聘信息中的可能是指的英文中的 Proficient 也就和 熟练（掌握） 同样的层级，一般英文级别是 Novice / Basic / Proficient / Advance / Expert 这五个级别。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"},{"name":"简历","slug":"生活总结/简历","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/%E7%AE%80%E5%8E%86/"}],"tags":[{"name":"resume","slug":"resume","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/resume/"},{"name":"level","slug":"level","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/level/"}]},{"title":"Emacs Keymap 优先级","slug":"工具环境/emacs/emacs-keymap-priority","date":"2019-07-31T01:09:00.000Z","updated":"2020-01-06T02:54:32.360Z","comments":true,"path":"2019/07/31/工具环境/emacs/emacs-keymap-priority/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/07/31/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-keymap-priority/","excerpt":"","text":"编写 Emacs 的配置文件，无论如何也不能绕开快捷键，对于快捷键一般都是 define-key 方法来实现按键绑定，但是对于不同的 keymap 拥有不同的优先级，通过 keymap 优先级，可以了解到快捷键间的覆盖关系。 key-translation-map : 最高级，就是把这个键的意义改变了，想使用原来的快捷键，要重新进行绑定 minor-mode-map : 二级，只在 minor mode 激活时启作用，其它时候会被其它的快捷键覆盖掉 local-set-key : 三级，在 major mode 中启作用 global-set-key : 最弱的级别，但是也是最简单的键绑定方式","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"keymap","slug":"keymap","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/keymap/"},{"name":"keybinds","slug":"keybinds","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/keybinds/"}]},{"title":"brew 不常用命令","slug":"工具环境/mac/brew-unused-command","date":"2019-07-31T00:52:00.000Z","updated":"2020-01-06T02:53:01.264Z","comments":true,"path":"2019/07/31/工具环境/mac/brew-unused-command/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/07/31/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/mac/brew-unused-command/","excerpt":"","text":"brew services 命令是用来管理 Mac 系统中后台服务的，比如在 Mac 上安装了 MySQL ，当我希望将这个变成一个后台服务启动的时候，可以使用，有点像 Linux 下的 service 和 systemctl 两个命令。 具体的使用命令也非常简单： 123456brew services list # 查看使用brew安装的服务列表brew services run formula|--all # 启动服务（仅启动不注册）brew services start formula|--all # 启动服务，并注册brew services stop formula|--all # 停止服务，并取消注册brew services restart formula|--all # 重启服务，并注册brew services cleanup # 清除已卸载应用的无用的配置","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"}],"tags":[{"name":"brew","slug":"brew","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/brew/"},{"name":"服务列表","slug":"服务列表","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E6%9C%8D%E5%8A%A1%E5%88%97%E8%A1%A8/"}]},{"title":"Emacs 中辅助键设置","slug":"工具环境/emacs/emacs-hyper-keybinds","date":"2019-07-31T00:50:00.000Z","updated":"2020-01-06T02:53:46.965Z","comments":true,"path":"2019/07/31/工具环境/emacs/emacs-hyper-keybinds/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/07/31/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-hyper-keybinds/","excerpt":"","text":"使用 Emacs 的人，一般都对快捷键的前缀 C 和 M 键不陌生，但其实在 Emacs 中，除了常见的 C 和 M 之外，还有 s 和 H 两个辅助键，但是在不同的操作系统中，辅助键的设置方法也是不一样的，但是我们可以通过在 init.el 文件中设置键位来保证快捷键的一致。 在 windows 系统下 12345678(setq w32-pass-lwindow-to-system nil)(setq w32-lwindow-modifier &#39;super) ; Left Windows key(setq w32-pass-rwindow-to-system nil)(setq w32-rwindow-modifier &#39;super) ; Right Windows key(setq w32-pass-apps-to-system nil)(setq w32-apps-modifier &#39;hyper) ; Menu&#x2F;App key 在 Mac 系统下 1234(setq mac-command-modifier &#39;meta) ; make cmd key do Meta(setq mac-option-modifier &#39;super) ; make opt key do Super(setq mac-control-modifier &#39;control) ; make Control key do Control(setq ns-function-modifier &#39;hyper) ; make Fn key do Hyper 在如此配置之后，绑定快捷键过程中，super 对应的是 s 前缀，hyper 对应的是 H 的前缀。 12(global-set-key (kbd &quot;H-b&quot;) &#39;backward-word) ; 绑定的 Hyper 键(global-set-key (kbd &quot;s-b&quot;) &#39;backward-word) ; 绑定的 super 键","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"keymap","slug":"keymap","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/keymap/"},{"name":"super","slug":"super","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/super/"},{"name":"hyper","slug":"hyper","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/hyper/"}]},{"title":"Mac 电脑上使用 Emacs","slug":"工具环境/emacs/emacs-in-mac","date":"2019-07-28T19:17:00.000Z","updated":"2020-01-06T02:53:57.907Z","comments":true,"path":"2019/07/29/工具环境/emacs/emacs-in-mac/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/07/29/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-in-mac/","excerpt":"","text":"在 Mac 上使用 Emacs 有两个方案，从 Emacs For Mac OS X 手工下载，然后更新本地，或者是在 homebrew 中增加配置，然后利用 brew upgrade 从 homebrw-emacsmacport 上进行下载和更新。 两种方式获取的 Emacs 有少许不同，具体的见两个项目的简介。 第二种方法的命令如下： 12brew tap railwaycat/emacsmacportbrew install emacs-mac 安装之后，如果要从启动台启动应用，需要在 /applications 和安装位置增加软链接，命令如下 1ln -s /usr/local/opt/emacs-mac/Emacs.app/Applications 这样之后就可以直接在 Alfred 中输入 emacs 直接启动。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"install Emacs","slug":"install-Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/install-Emacs/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/Mac-OS/"}]},{"title":"实现自己的子弹笔记","slug":"生活总结/bullet-journal-for-myself","date":"2019-07-17T18:47:00.000Z","updated":"2020-01-05T13:45:47.914Z","comments":true,"path":"2019/07/18/生活总结/bullet-journal-for-myself/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/07/18/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/bullet-journal-for-myself/","excerpt":"","text":"已经坚持记笔记和做手帐有大概 2 年的时间了，从最开始的只是记，到后来的坚持用手帐进行时间管理，让我获益良多，从最开始的记到后来的边记边思考，到再后来的不停的换手帐的内容，随着改变，也越来越习惯于手帐本身。 最近买了一本 《子弹笔记》 一直在阅读和学习其中的方法，确实比自己的要谘和有用，但是简单的照搬却又不太习惯，所以想整理一下其中有用的思想，然后进行个性化。 子弹笔记官方网站：https://bulletjournal.com/ 思想清单 第一栏列出所有的 正在 做的事情 第二栏列出所有的 应该 做的事情 第三栏列出所有的 你想 做的事情 回顾思想清单 画去不要紧的，或者不重要的内容 找出相关的内容，创建个性化的集子 迁移思想清单 把未来事项移入未来记录 把当月事项移行进月度记录 为月度记录排列主次 把优先事项迁移进每日记录 把附加事项迁移进对应的修改化集子 关键内容索引 : 利用标题和页码定位笔记的内容，而索引无需连续；专用索引与集子类似，提供特定的主题的索引 未来记录 : 用来记录本月以外的任务和事件 月度记录 : 用于一览本月的时间安排和任务。也可以作为你本月的思想清单 每日记录 : 用于快速记录下每一天里所有的想法 快速记录 : 利用简短的符号快速捕捉想法，分成笔记、事件、任务三类，并排序。 集子 : 笔记中模块化的构成部分，用于储存紧密相关的内容。核心领子有索引、未来记录、月度记录、每日记录，但也支持个性化设计。 迁移 : 每月从笔记本中过滤掉的无意义的内容的过程 快速记录中，任务、事件、笔记三种的意义： 任务 : 需要 做的事情，用 “.” 标记，同样的，迁移任务使用 “&gt;” 标记，计划中的任务用 “&lt;” 标记，移除的任务用 删除线 表示 事件 : 经历 过的事情，用 “o” 标记 笔记 : 不想遗忘 的事情，用 “-” 标记 特殊的一些标记，比如重点任务、灵感、长笔记 重点任务 : 在任务前加 “*” 灵感 : 在任务前增加 “!” 长笔记 : 有特殊的想法或者想额外的记录一些内容，使用 “+” 标记 日历页在日历页上，左侧按顺序列出日期，并在日期右侧附上星期，在左侧留出空白空间，以便后续增加特殊符号。 任务页月度记录中的任务页是不断的更新的思想清单，如果有最终的时候，可以未完成的时候进行迁移，也可以调整日期。 未来记录未来记录主要是将本月无法完成的项目，提前写入到未来日记中，或者是读书、学习的特殊记划，这样在月度记录的时候，就能很好的规划我们的生活。 引线法索引有时候页码不连续，但是使用过程中，又不想过多翻回到索引页观看，可以使用引线法，比如在第二块的初始页面中，可以使用 “当前页码/前一部分页码” 的形式进行记录，而同理，结束部分则使用 “后一部分页码/当前页码” ，这种方式可以扩展到不同的本子中，比如使用 “第几册.第多少页” 这种形式记录。 计划旅行计划描述 : 包括要去什么地方，要做什么，和谁一起去，是旅行还是休闲 目的地 : 记录了这次要去的地方，包括景点、住宿等 活动 : 想做什么？旅伴想做什么？ 时间 : 航班时间、当地交通、活动的时间等 预算 : 机票、租车、住宿、汽油、伙食、活动、购物、礼品 行程计划要记录我们出行过程中的事情，比如从哪儿飞到哪儿，怎么入住，有什么特殊的事件吗，等等问题，可以按地点进行记录。 第一栏记录机场，包含对应的事件的页码 第二栏记录时间，包括星期和日期 第三栏记录时间轴上的任务，比如入住酒店、退房、飞住什么地方、要做事情，可以有效的进行规划 个性化调整长笔记长笔记可以记录某一件事情的后续，或者是有什么想法，为什么有这个想法，或者是与人发生了什么样的交流，甚至是思考了什么问题，或者是对某件事的感想，这些可以培养记录的好习惯。 习惯养成这个是与月历相关，可以在页面上记录一个月的习惯养成情况，与日历上的日期一一对应，比如坚持运动、阅读等事情，或者是增加一些希望养成的习惯。 针对阅读，可以设定为阅读某一本书，或者是阅读多少时间，这样可以让任务更具体，而越是具体的任务，越容易完成。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"},{"name":"手帐","slug":"生活总结/手帐","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/%E6%89%8B%E5%B8%90/"}],"tags":[{"name":"子弹笔记","slug":"子弹笔记","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E5%AD%90%E5%BC%B9%E7%AC%94%E8%AE%B0/"},{"name":"手帐体系","slug":"手帐体系","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E6%89%8B%E5%B8%90%E4%BD%93%E7%B3%BB/"}]},{"title":"Android 刷机实践","slug":"工具环境/android-flashboot","date":"2019-04-10T00:44:00.000Z","updated":"2020-01-06T02:52:25.356Z","comments":true,"path":"2019/04/10/工具环境/android-flashboot/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/04/10/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/android-flashboot/","excerpt":"","text":"获取#在刷机之前，需要在电脑上下载 Android Preview 包，一般我都是到安卓中国 ，这里可以下载最新的包。 手机相对下载包的获取，比较难的是有一部支持最新的安卓系统的手机，一般 Preview 版的系统都是默认支持 Google 自己的手机的。 目前只支持 Pixel 系列的手机，包括 XL 系列。 Pixel n Pixel n XL 刷机刷机目前有两个比较麻烦的地方，第一就是需要安装 adb 的命令，也就是 Android 的功能模块，第二就是需要解锁手机。 adb 配置即将 Android SDK 下载下来，然后将其配置到环境变量中即可 Windows 配置 ANDROID_HOME 变量到环境变量中 配置 %ANDROID_HOME%\\platform-tools 到 path 中 配置 %ANDROID_HOME%\\tools 到 path 中 Linux &amp; Mac打开 profile 文件，默认为 .bash_profile 如果使用的是 zsh 则编辑 .zshrc 文件。 将下面的内容放到 profile 文件中 123ANDROID_HOME=~/developerTools/adt-mac/sdkexport ANDROID_HOMEPATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools MacMac 电脑提供了一个自动安装的内容，可以将 adb 相关的内容直接安装，但是如果是想开发 Android 应用的话，则必须要按上面的方案进行配置。 首先需要先安装 brew ，具体方案见 Homebrew ，或者可以直接看其 GitHub 的主页 Homebrew/brew 。 然后执行下面的命令 1brew cask install android-platform-tools 如果执行刷机的时候，提示 fastboot is too old 则需要重新安装 android-platform-tools , 因为 brew update 更新是不能更新 cask 库的内容的。 1brew cask reinstall android-platform-tools 最后，在命令行中执行 adb devices 不报错刚配置成功。如果配置之后，还依然报错的话，可以检查一下是否在使用过程中，将 USB 调试功能 关闭了。 操作 连接手机 adb devices 获取手机的 device id adb reboot bootloader 进入 bootloader 模式 如果已经解锁了，则进入第8步，如果未解锁则进入第五步 进入到 bootloader 之后，执行 fastboot flashing unlock 如果是 Pixel 2 XL 则执行 fastboot flashing unlock_critical 如果是更早的设备，则需要执行 fastboot oem unlock 进入下载的目录，然后执行 flash-all 脚本，如果是 Windows 则是 flash-all.bat ，其它的则执行 flash-all.sh 执行结束后，手机就已经刷好了，重启就可以使用了 如果执行失败的话，就需要解压目录下的 image 对应的包，然后执行下面的命令 123fastboot flash vendor vendor.imgfastboot flash boot boot.imgfastboot flash system system.img 然后重启手机就可以了。 V 版手机解锁需要刷入一个工具，才能解锁 123adb push dePixel8 /data/local/tmpadb shell chmod 755 /data/local/tmp/dePixel8adb shell /data/local/tmp/dePixel8 然后再执行 adb reboot bootloader 就可以正常解锁了。 dePixel8.zip 下载 判断是否 V 版手机 1adb shell getprop|grep cid 如果出现 VZW_001 就是 V 版手机","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Android","slug":"工具环境/Android","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Android/"}],"tags":[{"name":"安卓系统","slug":"安卓系统","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F/"},{"name":"手动更新手机系统","slug":"手动更新手机系统","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"Emacs 功能键配置","slug":"工具环境/emacs/emacs-modifier-keys","date":"2019-02-25T22:10:00.000Z","updated":"2020-01-06T02:56:35.110Z","comments":true,"path":"2019/02/26/工具环境/emacs/emacs-modifier-keys/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/02/26/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-modifier-keys/","excerpt":"","text":"Emacs 和 Vim 最大的就是快捷键的体系不同，在 Emacs 中，快捷键要有对应的控制键配合，才能正常使用，比如打开 Agenda C-c a 一般指的是 Ctrl + c a 而在 Emacs 中，使用的控制键主要有以下几种： 12345s- : supperS- : ShiftM- : Meta &#x2F; AltC- : CtrlH- : Hyper 其中 Ctrl、Meta/Alt、Shift这几种快捷键比较常见，但是 supper 这个键就比较少见了，而且在键盘上，一般也看不到，所以我们在配置的时候，需要在配置中声明这几个键被绑定在哪些键上。 如果是在 /Windows/ 系统下需要增加如下的配置： 12(setq w32-lwindow-modifier &#39;supper w32-apps-modifier &#39;hyper) 但是如果使用的是 /Mac/ 系统的话要增加如下配置： 1234(setq mac-command-modifier &#39;meta mac-option-modifier &#39;super mac-control-modifier &#39;control ns-function-modifier &#39;hyper) 但是这样的情况又有另外一个问题，需要在特定的系统中使用，所以我们要在对应的配置上增加上对系统的判断，绑定的方案如下： 1234567891011(when sys&#x2F;winntp ;; 经过测试，在 windows 下，window 键是不能修改的 (setq ;;w32-lwindow-modifier &#39;supper w32-apps-modifier &#39;hyper) (w32-register-hot-key [s-t]))(when sys&#x2F;macp (setq mac-command-modifier &#39;meta mac-option-modifier &#39;super mac-control-modifier &#39;control ns-function-modifier &#39;hyper)) 这样我们就可以在不同的系统中正确的使用不同的功能键了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"modifier keys","slug":"modifier-keys","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/modifier-keys/"}]},{"title":"让自己生活的更好","slug":"生活总结/3-step-to-better-one","date":"2019-02-11T00:13:00.000Z","updated":"2020-01-06T03:04:25.184Z","comments":true,"path":"2019/02/11/生活总结/3-step-to-better-one/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2019/02/11/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/3-step-to-better-one/","excerpt":"","text":"学会早睡想要早睡，需要减少自己的兴奋点，在生活中，如果无法早睡，白天的工作效率也就会降低，可能要拖拉到半夜才完成，这样就成了一个恶性循环了。 我尝试过早睡，但是未必能早起，主要是就算我10点躺下，也不可能在10点半入睡，毕竟手机、pad等等太好玩了。 所以想要早睡的会，要学会给自己降噪。 早一点运动和洗澡，避免淋水让自己重回清醒状态； 调暗室内灯光，尽量用暖色灯； 点燃香薰，或者其它助眠的东西； 阅读简单轻快的小说或者看一些轻松的视频，不要让自己兴奋或者让自己思考； 放下手机； 努力运动作为已经迈入中年油腻男境界的人来说，其实可以好的，比如给自己更好的身材，就算光头也可以很有型，所以运动是必不可少的，不过现在的我还是先从减肥开始，这里就不会有更多的问题，就是坚持二字，必然会瘦下来。 断舍离生活断舍离“把不用的东西扔掉！” 这是非常简单的几乎所有人都知道的真理，但是在生活中，不用的东西到底是怎么定义的，我现在不用，将来也不会用到的一定是。但是我们怎么知道将来会不会呢？ 所以应该把自己的物欲降低，先从不买或者真正有用或者想用的时候再买，千万不能图打折，图降价而购入一些不需要的东西。 特别是对于自己有吸引力的东西，对我来说，最常购买的东西就是图书，经常看到当当网、京东网、亚马逊有便宜的或者折扣的力收的时候就管不住自己的手，而有一些商家还经常用优惠来吸引人。结果导致了购买了许多的书，但是实际上看的书特别少。 所以在这里，自己定义了一个新的书单，用来记录自己实际读了什么、要读什么，再定一个计划，比如：阅读多少本已购书籍之后再购入新的书籍。 对于一些可能用又不可能不用，或者近一年都不会用的东西都扔掉，这样就可以让我们的家更整洁。等到一年后或许你发现你也不会用这个东西了。或者是再重新购入即可。 思想断舍离除了我们的生活，对于我们的思想也应该 “断舍离” 。 当有了一个想法，如果一直想着，就会把时间和记忆固定在这里，而如果中途又遇到另外的事情，又特别容易将某些事情忘记，所以我们应该选择记下来，用实体的东西代替大脑，这样可以让我们思考更多的东西。 或者我们忽然读到了一篇好文章，但是现在不适合详读，我们可以在这个是时候把文章通过工具记录下来，等有时间了，再重新详读这篇文章。 比如在通勤的路上，会遇到一些比较好的文章，我会利用手机 app 将文章保存到 滴答 清单中，当有时间的时候，将好的文章再重新阅读一遍，或者重新学习一遍。 当然有时候，也会因为懒怠繁忙导致累积了许多内容没有读，最多的时候，滴答的待办清单中有500篇文章要读。 除了这些，还可以把自己心中的那些不满啊、忧愁啊都记下来，这样也可以有效的控制我们的感情，让自己更开心的生活。 这个主要用了两个东西，一个是电子版的笔记系统——Org Mode Journal系统，另外一个就是一个简单的横格本和一支笔就可以手工记录了，具体的可以看一些手帐相关的文章来学习如何简单清晰的记录生活。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"},{"name":"生活","slug":"生活总结/生活","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"减法生活","slug":"减法生活","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E5%87%8F%E6%B3%95%E7%94%9F%E6%B4%BB/"}]},{"title":"Linux 查看端口占用情况","slug":"工具环境/linux/ensure-port-use-on-linux","date":"2018-09-03T18:53:00.000Z","updated":"2020-01-07T01:40:25.855Z","comments":true,"path":"2018/09/04/工具环境/linux/ensure-port-use-on-linux/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/09/04/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/linux/ensure-port-use-on-linux/","excerpt":"","text":"Linux 查看启动的后台进程，可以使用下面两个命令。 lsoflsof -i:&lt;port&gt; 用来查看某一端口占用情况，可以查询到对应的 COMMAND PID USER TYPE。 netstatnetstat -tunlp | grep &lt;port&gt; 用于查看指定的端口号的进程情况，可以查看端口的监听情况，最后一项则是对应的 COMMAND 和 PID。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"lsof","slug":"lsof","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/lsof/"},{"name":"netstat","slug":"netstat","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/netstat/"}]},{"title":"Git 上传文件超出最大值","slug":"工具环境/git/git-hung-up-unexpectedly","date":"2018-08-30T01:00:00.000Z","updated":"2020-01-07T08:10:03.154Z","comments":true,"path":"2018/08/30/工具环境/git/git-hung-up-unexpectedly/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/08/30/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-hung-up-unexpectedly/","excerpt":"","text":"昨天在上传打包的程序的时候，git 意外报错了，试了一下，并不是因为有冲突什么的，仔细看了一下报错： 发现是 OpenSSL 中报的错，确认了一下 error 发现是因为上传的文件过大导致的。需要将 postbuffer 调整一下： 1git config http.postbuffer 523288000 再上传一次，果然可以了。查询一下看看到底修改了什么 1git config --list 确认是修改了对应的最大 post 的请求的值。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"postbuffer","slug":"postbuffer","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/postbuffer/"},{"name":"hung up","slug":"hung-up","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/hung-up/"}]},{"title":"cmder 无法显示中文","slug":"工具环境/cmder-cannot-display-chinese","date":"2018-08-29T01:04:00.000Z","updated":"2020-01-06T02:53:37.744Z","comments":true,"path":"2018/08/29/工具环境/cmder-cannot-display-chinese/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/08/29/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/cmder-cannot-display-chinese/","excerpt":"","text":"cmder 默认是不支持中文字符的，可以在 Setting &gt; Startup &gt; Environment 下增加一行语言设置： 1set LANG=zh_CN.UTF8 然后重启 cmder 即可。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Windows","slug":"工具环境/Windows","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Windows/"}],"tags":[{"name":"cmder","slug":"cmder","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/cmder/"}]},{"title":"编写自己的 Hugo 主题","slug":"前端开发/create-new-theme-for-hugo","date":"2018-08-21T22:38:00.000Z","updated":"2020-01-06T02:49:17.239Z","comments":true,"path":"2018/08/22/前端开发/create-new-theme-for-hugo/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/08/22/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/create-new-theme-for-hugo/","excerpt":"","text":"页面使用 hugo new theme paladin 直接创建一个新的主题，然后可以在当前博客中（已经完成了多篇文章，但是还想自己定义一个主题）或者在新主题中增加测试用的项目。 目前所实现的大概样式如下： 创建之后，在 themes 目录下可以看到整个项目结构: 1234567891011121314151617181920themes&#x2F;paladin├── LICENSE├── archetypes│ └── default.md├── layouts│ ├── 404.html│ ├── _default│ │ ├── baseof.html│ │ ├── list.html│ │ └── single.html│ ├── index.html│ └── partials│ ├── footer.html│ └── header.html├── readme.md├── static│ └── css│ └── stylesheet.css└── theme.toml6 directories, 12 files 可以看到目录下有一些已经创建好的 html 目录，有几个需要编辑的，分别是 single.html ， index.html ， 404.html ， footer.html 和 header.html 这几个文件。 _default这里放的，是主要几个网站模板，用来提交一些默认的配置的。 single.html 这个是用来渲染生成的单页文章的，主要是 content/ 下的内容，可以用来渲染页面的名称、作者、时间和文章的具体内容。 list.html 这个是用来渲染生成的列表页的，包括文章列表页或者是标签列表和分类列表页。 partials这个目录下主要是放需要利用的代码片断，通过 partial 方法调用。 header.html 这里主要定义 &lt;head&gt; 标签和导航栏 &lt;nav&gt; 相关内容。 footer.html 这里定义了网页脚标位置的相关内容。 实现主题参照了 hugo-theme-hiruko 的样式，去掉了一些用不到的功能。 主要使用了bootstrap4，其中的一些图标来源自阿里巴巴的矢量库，用起来方便快捷。 当文章过多时，可以使用连续页面的样式，如果不想使用，可以用上一页下一页的方式。通过参数 paginateOriginalStyle 来控制，如果为 true 则是上一页下一页的样子，如果是 false 则如下图： 将社交链接和logo放到到 about.html 页面中，可以方便的看到作者的相关内容。 如果想修改logo的话，需要修改主题目录下的 static/media/zlogo.png 文件即可。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"hugo","slug":"前端开发/hugo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/hugo/"}],"tags":[{"name":"Hugo","slug":"Hugo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/Hugo/"},{"name":"theme","slug":"theme","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/theme/"}]},{"title":"用 Python 爬取小说","slug":"后台技术/python/python-download-novel","date":"2018-08-14T18:41:00.000Z","updated":"2020-01-06T09:22:24.899Z","comments":true,"path":"2018/08/15/后台技术/python/python-download-novel/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/08/15/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/python/python-download-novel/","excerpt":"","text":"Python 爬取网络的内容是非常方便的，但是在使用之前，要有一些前端的知识，比如： HTML、 CSS、XPath 等知识，再会一点点 Python 的内容就可以了。 因为使用的是 Anaconda ，所以大多数的包都已经有了，但是在使用过程中也有一些小问题，但是最终程序是实现了的。 BeautifulSoup 是一个可以从HTML或XML文件中提取数据的Python库。非常好用，具体的 文档可以从这里跳转 ，利用这篇文章可以让你轻松的进行网页的解析。可以把仅有的一点前端知识也略去了。 requests 适合正常人类使用的一个 HTTP 解析工具 time 让网站以为你不是电脑 sys 显示和刷新 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# _*_ coding:UTF-8 _*_from bs4 import BeautifulSoupimport requestsimport timeimport sys\"\"\"download 《武动乾坤》 from www.biqukan.comParameters: NoneReturns: None\"\"\"class downloader(object): def __init__(self): self.server = \"http://www.biqukan.com\" self.target = \"http://www.biqukan.com/3_3012\" self.names = [] self.urls = [] self.nums = 0 \"\"\" To get Urls for download \"\"\" def get_download_url(self): req = requests.get(url=self.target) html = req.text div_bf = BeautifulSoup(html, \"html.parser\") div = div_bf.find_all(\"div\", class_=\"listmain\") a_bf = BeautifulSoup(str(div[0]), \"html.parser\") a = a_bf.find_all(\"a\") self.nums = len(a[12:]) with open('武动乾坤目录.txt', 'a', encoding='utf-8') as f: for each in a[12:]: f.write(each.string) self.names.append(each.string) f.write(self.server + each.get(\"href\")) self.urls.append(self.server + each.get(\"href\")) \"\"\" To get content Parameters: target - 下载链接 Returns: content - 章节内容 \"\"\" def get_contents(self, target): headers = requests.utils.default_headers() headers['User-Agent'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 Firefox/61.0' req = requests.get(url=target, headers=headers) html = req.text bf = BeautifulSoup(html, \"html.parser\") texts = bf.find_all(\"div\", class_=\"showtxt\") content = texts[0].text.replace('\\xa0' * 8, '\\n\\n') return content \"\"\" To save to text Parameters: name - 章节名称 path - 当前路径 + 小说名 text - 章节内容 Returns: None \"\"\" def writer(self, name, path, text): # writer_flag = True with open(path, 'a', encoding='utf-8') as f: f.write(name + '\\n') f.writelines(text) f.write('\\n\\n')if __name__ == \"__main__\": dl = downloader() dl.get_download_url() print(\"第\", dl.nums, \"章\") print(\"开始下载:\") for i in range(dl.nums): time.sleep(1) dl.writer(dl.names[i], '武动乾坤.txt', dl.get_contents(dl.urls[i])) sys.stdout.write(\" 已下载:%.3f%%\" % float(i/dl.nums*100) + '\\r') sys.stdout.flush() print(\"下载完成\") 几个小点需要注意： 不能访问的过快，所以在循环中进行一次等待，我这里用的是 time.sleep(1) 为了不被反爬虫识别为爬虫，需要在访问的时候，增加一个 header ，利用 headers = requests.utils.default_headers() 和 headers[&#39;User-Agent&#39;] = &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:61.0) Gecko/20100101 Firefox/61.0&#39; 两行，就可以不被识别了 解析的时候，出现了一个问题，就是一开始从目录页获取的时候，只能读取 193 篇文章，经过排查，发现是在使用 BeautifulSoup 的时候解析的有点问题，将原本的 &quot;lxml&quot; 方式修改为&quot;html.parser&quot; 方式就可以了 不过因为这本小说字数真的有点多，所以下载过程有点慢，不过整体来说还是可以使用的。","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"Python","slug":"后台技术/Python","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/Python/"}],"tags":[{"name":"beautifusoup","slug":"beautifusoup","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/beautifusoup/"},{"name":"下载小说","slug":"下载小说","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E4%B8%8B%E8%BD%BD%E5%B0%8F%E8%AF%B4/"}]},{"title":"apt-get 中 update 与 upgrade 的区别","slug":"工具环境/linux/apt-get-update-and-upgrade","date":"2018-08-02T01:14:00.000Z","updated":"2020-01-06T02:52:53.681Z","comments":true,"path":"2018/08/02/工具环境/linux/apt-get-update-and-upgrade/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/08/02/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/linux/apt-get-update-and-upgrade/","excerpt":"","text":"update : 更新 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的地址,这样才能获取到最新的软件包。upgrade : 升级已安装的所有软件包，升级之后的版本就是本地地址里的，因此，在执行 upgrade 之前一定要执行 update , 这样才能更新到最新的。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"apt-get","slug":"apt-get","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/apt-get/"},{"name":"apt","slug":"apt","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/apt/"}]},{"title":"Eclipse 项目层次结构设置","slug":"工具环境/eclipse-package-presentation","date":"2018-07-31T22:29:00.000Z","updated":"2020-01-06T09:25:45.817Z","comments":true,"path":"2018/08/01/工具环境/eclipse-package-presentation/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/08/01/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/eclipse-package-presentation/","excerpt":"","text":"Eclipse 中新建工程或者是导入一个工程，包层次默认为 Flat ，也就是完成名称，但是这种显示会让包结构非常复杂，而且非常不好找，一般我是将其配置为 Hierarchical 即分层次的。 路径在 Windows-&gt;Navigation-&gt;Show View Menu-&gt;Package Presentation-&gt;Hierarchical 下，调整后，包会按文件夹样式一层层显示。 当然，也可以使用快捷键 Ctrl + F10 打开，将 Package Presentation 调整为 Hierarchical 即可。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Eclispe","slug":"工具环境/Eclispe","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Eclispe/"}],"tags":[{"name":"presentation","slug":"presentation","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/presentation/"}]},{"title":"利用 Travis 自动部署博客","slug":"工具环境/deploy-blog-by-travis","date":"2018-07-14T18:27:00.000Z","updated":"2020-01-06T09:12:24.086Z","comments":true,"path":"2018/07/15/工具环境/deploy-blog-by-travis/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/07/15/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/deploy-blog-by-travis/","excerpt":"","text":"Travis CI 是一个非常好用持续集成工具。 集成 主要是用来将多个用户的开发模块构建成一个可运行版本；而 持续集成 则是在集成之上，尽量将每一次提交都进行一次构建，这个个过程就是 持续集成 。 Travis 自动构建Travis Ci 的自动构建周期分为两步： install Script 但是我们可以根据这两步将相关的内容分成更细的步骤： before_install install befor_script script after_success 或者 after_failure before_deploy deploy after_deploy after_script 持续集成就是把一系列的手工操作合并成一个脚本的过程。 所以可以这样实现部署脚本: 12345678910111213141516sudo: falselanguage: goos: osxinstall: brew install hugoscript: - hugo --config jane-config.tomlbranches: only: - sourceafter_success: - git add -A - git commit -m \"update blog\" - git push -u origin master 这个脚本中，我们主要工作是生成 hugo 博客这一步，如果成功了，我们就进行提交，也就完成了。 Travis GitHub Pages经过查阅之后，发现 Travis Ci 本身就支持直接部署到 GitHub Pages 上，并拥有单独的章节。 个人令牌在 GitHub 中的 Setting 下的 Developer settings 中，有一个 Personal access tokens 中，可以生成，然后配置到 Travis Ci 对应的 My Repositories 中的项目中，一般的话，使用 public_repo 权限就足够了。 如果在 My Repositories 中看不到 Settings ，可以在 More options 中找到 Settings 然后在 Environment Variables 中配置对应的令牌即可。 个人配置在项目中新增 .travis.yml ，内容如下： 12345678deploy: provider: pages skip-cleanup: true github-token: $GITHUB_TOKEN # Set in the settings page of your repository, as a secure variable keep-history: true on: branch: master GitHub Pages 默认的一些参数： local-dir: 推送到 GitHub Pages 的目录，当前路径的相对路径，默认为当前路径 repo: 项目仓库的地址，默认为当前项目 keep-history: 可选参数，使用递增的推送信息代替强制推送，默认为 false target-branch: 将 local-dir 内容推送的分支，默认为 gh-pages ，如果 keep-history 为 true ，则强制推送 git push -f fqdn: 可选参数，设置用户的自定义域名，默认为无自定义域名 project-name: 默认为 fqdn 的值或者是仓库的固定路径，用于元数据 email: 可选参数，提交人信息，默认为 deploy@travis-ci.org name: 可选参数，提交人，默认为 Deployment Bot committer-from-gh: 可选参数，默认为 false ，允许令牌拥有者使用，会覆盖掉 email 和 name 两个的值 allow-empty-commit: 可选参数，默认为 false ，仅在 keep-history 参数为 true 时启用 github-url: 可选参数，默认为 github.com ，是企业级自托管 GitHub 项目的 URL 地址 verbose: 可选参数，冗余的内部步骤，默认为 false 备注： 默认情况下，travis 会自动执行 git submodule init ，但是需要使用 https 的路径，否则需要配置 ssh key ，而 GITHUB_TOKEN 要保证和 travis 设置的变量一致，名称和值都要一致 fqdn 如果需要设置自定义域名，可以设置这个参数，travis 会自动生成 CNAME 文件提交，同时要设置 config.toml 中的相应的 baseURL branches: only: source 等价于 deploy: on: branch: source Environment Variables除了令牌之后，我们也可以将 name 、 email 等相关信息配置到这里，比如推送的分支，可以设置为 P_BRANCH 然后在推送的时候，使用 ${P_BRANCH} 来引用。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"travis","slug":"工具环境/travis","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/travis/"}],"tags":[{"name":"hugo","slug":"hugo","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/hugo/"},{"name":"travis","slug":"travis","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/travis/"},{"name":"自动部署博客","slug":"自动部署博客","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"}]},{"title":"新增 MySQL 用户","slug":"后台技术/mysql/mysql-create-new-user","date":"2018-07-11T23:17:00.000Z","updated":"2020-01-07T09:08:09.058Z","comments":true,"path":"2018/07/12/后台技术/mysql/mysql-create-new-user/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/07/12/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/mysql/mysql-create-new-user/","excerpt":"","text":"创建本地用户 1create user 'test'@'localhost' identified by 'password'; 创建局域网用户 1create user 'test'@'%' identified by 'password'; 刷新 1flush privileges; 修改密码 1set password for 'test'@'localhost' = password('newpassword'); 如果是当前用户： 1SET PASSWORD = PASSWORD(\"newpassword\"); 授权 授权相关操作见: MySQL 数据库设置远程权限 这里补充一下 MySql 移除权限的命令： 1REVOKE privilege ON databasename.tablename FROM 'username'@'localhost'; 删除用户 1drop user 'username'@'localhost'","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"create user","slug":"create-user","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/create-user/"},{"name":"set password","slug":"set-password","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/set-password/"}]},{"title":"Ajax 关闭异步请求","slug":"前端开发/ajax-asyn-option","date":"2018-06-19T23:21:00.000Z","updated":"2020-01-06T02:50:38.428Z","comments":true,"path":"2018/06/20/前端开发/ajax-asyn-option/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/ajax-asyn-option/","excerpt":"","text":"在代码中，因为进行了后台的取值操作，导致有些内容还未加载就执行到了新的地方，所以想着 ajax 的异步关闭来解决。 async 设置为 false 的时候，变成同步操作，默认( true )为异步操作。 12345$.ajax(&#123; cache: false, async: false, // 太关键了，学习了，同步和异步的参数&#125;);alert(\"2\");","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"ajax","slug":"前端开发/ajax","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/ajax/"}],"tags":[{"name":"async","slug":"async","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/async/"},{"name":"异步请求","slug":"异步请求","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/"}]},{"title":".gitignore 文件配置","slug":"工具环境/git/git-ignore","date":"2018-05-27T19:18:00.000Z","updated":"2020-01-07T08:15:02.241Z","comments":true,"path":"2018/05/28/工具环境/git/git-ignore/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/05/28/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-ignore/","excerpt":"","text":"git 使用过程中，有许多文件或者文件夹是不希望更新到远程仓库了，因为他们比较占地方，这个时候我们可以利用 .gitignore 文件忽略文件。 按项目进行忽略.gitignore 文件用于忽略文件 所有空行或者以没注释符号 # 开头的行都会被 Git 忽略。 可以使用 glob 模式进行匹配。 匹配模式最后跟反斜杠 (/) 说明忽略的是目录。 要忽略指定模式以外的文件或者目录，可以在模式前加上惊叹号。 glob 模式* : 表示任意个任意字符 ? : 表示匹配一个任意字符 所以我们只需要在对应的 git 目录下，创建一个 .gitignore 文件，然后配置上 .DS_Store 即可。 12touch .gitignoreecho */.DS_Store\" &gt; .gitignore 然后保存，就可以生效了。 全局进行配置然后我们发现，只要是 Mac 下的 Git 项目我们都需要这样操作一次，太麻烦了，所以我们可以在 home 目录下创建一个 .gitignore_global 文件，然后按 .gitignore 文件的配置方式完成配置。 在每个项目下的 .gitignore 文件中，我们可以引用这个 global 文件。 1git config --global core.excludesfile ~/.gitignore_global 这样就可以将全局方法加载到项目配置文件中了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":".gitignore","slug":"gitignore","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/gitignore/"}]},{"title":"使用 Mac 电脑制作 U 盘","slug":"工具环境/mac/create-usb-card-by-dd-in-mac","date":"2018-04-24T18:47:00.000Z","updated":"2020-01-06T08:35:37.981Z","comments":true,"path":"2018/04/25/工具环境/mac/create-usb-card-by-dd-in-mac/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/04/25/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/mac/create-usb-card-by-dd-in-mac/","excerpt":"","text":"Mac 下写入命令 找出 U 盘挂载位置 1diskutil list 将 U 盘移除 1diskutil unmountDisk /dev/disk[num] 写入 U 盘 1sudo dd if=isopath of=/dev/disk[num] bs=1m rdisk rdisk 是指定方式后，可以加快写入速度。 iso 转换为 dmg1sudo hdiutil convert -format UDRW -o linux.dmg kali.iso 弹出 U 盘1diskutil eject /dev/disk[num]","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Mac","slug":"工具环境/Mac","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Mac/"}],"tags":[{"name":"dd","slug":"dd","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/dd/"},{"name":"diskutil","slug":"diskutil","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/diskutil/"}]},{"title":"Git 补遗","slug":"工具环境/git/git-tips","date":"2018-04-20T03:22:00.000Z","updated":"2020-01-07T09:35:12.144Z","comments":true,"path":"2018/04/20/工具环境/git/git-tips/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/04/20/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-tips/","excerpt":"","text":"文件退出暂存区，但是保留修改在代码或者一些内容更新完成好，进行了 git add . 或者 git add -A 操作，但是发现操作错误了，不希望进行暂存区，但是又不想移除已经修改的内容，可以执行 git reset --mixed 操作，这样将文件退出暂存区，但是修改的内容保留。 多次修改，一次 commit在进行一个功能的开发过程中，希望将整个功能仅做一次 commit ，可以在修改完成后，执行 git add . ， 然后再执行 git commit --amend ，这样可以把修改的内容分次写入到 commit 文件中，最后再进行提交。 git 移除 cache 的内容 git 删除暂存区的文件，不会移除文件，即保留工作区。 1git rm --cache fileName fileName 为对应的文件名 删除暂存区和工作区的文件 1git rm -f fileName git 删除错误的 commit commitId 为对应的 id 仅仅撤销已经提交的版本库，不会个性暂存区和工作区 1git reset --soft commitId 撤销已提交的版本库和暂存区，不会修改工作区 1git reset --mixed commitId 彻底将工作区、暂存区和版本库记录恢复到指定的版本 1git reset --hard commitId 如果你希望保留修改，但是撤销提交，则使用 --mixed ，如果想彻底恢复，则使用 --hard","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"cache","slug":"cache","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/cache/"},{"name":"reset","slug":"reset","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/reset/"}]},{"title":"Surround 笔记","slug":"工具环境/emacs/evil-surround-learning","date":"2018-02-12T01:09:00.000Z","updated":"2020-01-07T01:46:47.226Z","comments":true,"path":"2018/02/12/工具环境/emacs/evil-surround-learning/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2018/02/12/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/evil-surround-learning/","excerpt":"","text":"surroud 插件项目的地址如下 vim surround 原文本 命令 新文本 “Hellow world!” ds” Hellow world! [123+456]/2 cs]) (123+456)/2 “Look ma, I’m *HTML!” cs” Look ma, I’m HTML! if x &gt; 3 { ysW( if( x&gt;3 ) { my $str = whee!; vllllS’ my $str = ‘whee!’; &lt;div&gt;Yo!&lt;/div&gt; dst Yo! &lt;div&gt;Yo!&lt;/div&gt; cst&lt;p&gt; &lt;p&gt;Yo!&lt;/p&gt; 上面的示例中，添加成对的括号时，如果使用后半括号，是没有空格的，如第 2 个示例，如果使用前半个括号，则是有空格的，如第 4 个示例。另外对于一些常见的标记，需要记住： t 表示 xml 或者 html 中的 Tag w word W WORD p paragraph 命令表格Normal modeds : 删除一对配对符号 cs : 替换原来的配对符号 ys : 加一对配对符号 yS : 增加一对配对符号，并将内容新建一行，并缩进 yss : 为整行增加一对配对符号 ySs : 为整行增加一对配对符号，并新起一行，然后缩进 ySS : 同 ySs Visual modes : 增加一对匹配符号 S : 增加一对匹配符号，并新起一行，然后缩进 Insert modeC-s : 增加一对匹配符号 C-s C-s : 增加一对匹配符号，并新起一行，然后缩进 C-g s : 增加一对匹配符号 C-G S : 增加一对匹配符号，新起一行然后进行缩进 修改 surrounding 内文本为例：ci : 修改匹配符号内的文本，并进入插入模式 di : 剪切匹配符号之间的文本 yi : 复制匹配符号之间的文本 ca : 同 ci 但是也修改符号本身 da : 同 di 但是也修改符号本身 ya : 同 yi 但是也修改箱号本身 b 可以表示小括号，B 表示大括号","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"evil","slug":"evil","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/evil/"},{"name":"surround","slug":"surround","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/surround/"}]},{"title":"Git 合并多次提交","slug":"工具环境/git/git-combine-commit-messages","date":"2017-08-02T03:33:00.000Z","updated":"2020-01-07T08:01:23.773Z","comments":true,"path":"2017/08/02/工具环境/git/git-combine-commit-messages/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2017/08/02/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-combine-commit-messages/","excerpt":"","text":"在合并分支的时候，希望将多次提交合并成一个，然后再 cherry-pick 到主分支。 合并分支develop 分支做开发，可能会进行多次提交，但是在发布或者进行 PR 的时候，我们只希望看到一次提交。这个时候，我们需要进行 git rebase 之后进行合并。 12# HEAD~3 表示将近三次提交都合并，如果是将 2 次合并则为 HEAD~2git rebase -i HEAD~3 这个时候，看到的是一上对 COMMIT 信息的提示 123456789101112131415161718192021pick 9ba5122 2017 年 8 月 2 日pick c6da035 ~~# Rebase 9b6bae1..c6da035 onto 9b6bae1 (2 commands)## Commands:# p, pick &#x3D; use commit# r, reword &#x3D; use commit, but edit the commit message# e, edit &#x3D; use commit, but stop for amending# s, squash &#x3D; use commit, but meld into previous commit# f, fixup &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message# x, exec &#x3D; run command (the rest of the line) using shell# d, drop &#x3D; remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 第一列对应的是 rebase 具体的操作，其含义如下 命令 作用 pick(p) git 会应用这个补丁，以同样的提交信息（commit message）保存提交 reword(r) git 会应用这个补丁，但需要重新编辑提交信息 edit(e) git 会应用这个补丁，但会因为 amending 而终止 squash(s) git 会应用这个补丁，但会与之前的提交合并 fixup(f) git 会应用这个补丁，但会丢掉提交日志 exec(x) git 会在 shell 中运行这个命令 drop(d) git 会移除这次 COMMIT 将第二个 pick c6da035 ~~~ 这一行修改成 squash c6da035 ~~~ ，使之与之前的提交合并。 保存之后可以看到下面的内容 12345678910111213141516171819202122232425This is a combination of 2 commits.# This is the 1st commit message:2017 年 8 月 2 日删除无用配置，提高启动速度1. 更新 zucchini-org2. 增加 CHANGELOG 用来记录每次更新3. 更新 plantuml 配置 FIXED Can&#39;t find plantuml-jar-path4. 增加 parinfer 配置，用来优化 lisp 的编写速度# This is the commit message #2:~~# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## Date: Tue Aug 1 10:24:44 2017 +0800## interactive rebase in progress; onto 9b6bae1# Last commands done (2 commands done):&quot;~&#x2F;spacemacs&#x2F;spacemacs.d&#x2F;.git&#x2F;COMMIT_EDITMSG&quot; 36L, 1003C 修改成正确的 commit 信息之后，保存存并退出，可以看到下面的内容 1234567$ git rebase -i HEAD~2[detached HEAD 0238691] 2017 年 8 月 2 日 Date: Tue Aug 1 10:24:44 2017 +0800 5 files changed, 65 insertions(+), 34 deletions(-) create mode 100644 CHANGELOG.org rewrite local/custom.el (66%)Successfully rebased and updated refs/heads/develop. 这个时候，就已经将我们这几次的更改都合并到一次中了。 cherry-pick 分支并更新这个时候，就可以更新我们的代码了。 首先 git checkout master 分支, 然后更新我们的代码 git pull 。 然后将我们合并之后的 develop 分支的内容更新过来 1git log -b develop 看到如下内容 12345678910111213commit 02386914b9e5ab13c23451a3463813bfdecb157aAuthor: 语乱 &lt;banshiliuli1990@sina.com&gt;Date: Tue Aug 1 10:24:44 2017 +0800 2017 年 8 月 2 日 删除无用配置，提高启动速度 1. 更新 zucchini-org 2. 增加 CHANGELOG 用来记录每次更新 3. 更新 plantuml 配置 FIXED Can&#39;t find plantuml-jar-path 4. 增加 parinfer 配置，用来优化 lisp 的编写速度 或者使用上次的操作的中的提示 [detached HEAD 0238691] 2017 年 8 月 2 日 其中的 0238691 就是我们需要 1git cherry-pick 0238691 这样我们再推送到远程就可以实现合并更新了。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"rebase","slug":"rebase","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/rebase/"}]},{"title":"Org mode 中不能执行 dot 、 Python 代码","slug":"工具环境/emacs/emacs-dot-and-python-cannot-run-in-spacemacs","date":"2017-07-30T19:23:00.000Z","updated":"2020-01-06T09:17:44.943Z","comments":true,"path":"2017/07/31/工具环境/emacs/emacs-dot-and-python-cannot-run-in-spacemacs/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2017/07/31/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-dot-and-python-cannot-run-in-spacemacs/","excerpt":"","text":"无法执行的代码 更新之后，dot 、 plantuml 的代码段在 Org-mode 下无法执行，需要引入对应的 ob-xxx.el 才能正常执行。 可以手工重新编译或者重新下载 Org 相关 package 即可，也可以使用下面的命令进行更新。 1:spacemacs&#x2F;recompile-elpa","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"spacemacs","slug":"spacemacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/spacemacs/"},{"name":"org babel","slug":"org-babel","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/org-babel/"}]},{"title":"刷新 Manjaro 源","slug":"工具环境/linux/flash-scoure-in-manjaro","date":"2017-06-08T00:49:00.000Z","updated":"2020-01-07T02:27:52.448Z","comments":true,"path":"2017/06/08/工具环境/linux/flash-scoure-in-manjaro/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2017/06/08/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/linux/flash-scoure-in-manjaro/","excerpt":"","text":"刷新 Manjaro 源，由快到慢并指定为中国源 1sudo pacman-mirrors -gb testing -c China 然后更新系统： 1sudo pacman -Syyu","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"工具环境/Linux","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Linux/"}],"tags":[{"name":"pacman","slug":"pacman","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/pacman/"}]},{"title":"Git 解决分支冲突","slug":"工具环境/git/git-rebase-merge","date":"2017-05-07T01:25:00.000Z","updated":"2020-01-07T09:08:31.105Z","comments":true,"path":"2017/05/07/工具环境/git/git-rebase-merge/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2017/05/07/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-rebase-merge/","excerpt":"","text":"在使用 git 进行版本管理的开发过程中，经常遇到上传或者拉取分支的时候冲突，在遇到冲突的时候，经常使用下面两个方式解决，虽然第一个方案看起来比较复杂，但是如果按我之前的文章: Git 工作流 进行工作的话，只需要执行3、4、5三步即可。 虽然提供的解决方案，但是最好还是从根源上降低冲突出现的频率才是最好的方案。 新建分支方法本文主要讨论 Git feature 与 master(develop) 分支冲突解决方案。 git pull : 同步远程分支，发现当前的开发流有了新的提交，且与自己开发的功能有冲突。 git checkout -b feature : Checkout 到 feature 分支。 git checkout master git pull origin master : 切换到 master 分支并拉取最新的内容。 git checkout feature git rebase master: 切换到 feature 分支并将 master 的修改合并，并解决冲突。 git add -A git rebase --continue : 将修改内容保存并继续 rebase 操作。 applying: xxxx : 看到这个提示表示已经完成了合并。 git checkout master git merge feature : 切换到 master 分支并将 feature 分支内容合并过来。 暂存提交方案在修改的时候，忘记新建对应的分支了，可以按上面的方案，但保存，然后创建新的分支，再将远程分支对应分支的内容 reset 回未修改的状态。或者使用 git stash 系列命令解决冲突。 git stash : 暂存修改的内容 git pull : 拉取最新的内容 git stash apply or git stash pop : 将暂存的内容合并进来 git stash 命令git stash apply : 应用暂存内容但是不删除，可以是最近的一次暂存，也可以按序号应用 git stash apply stash@{0}git stash drop : 移除暂存的内容git stash pop : 应用的同时从列表中移除，只能操作最近的一次 stash 的内容git stash list : 查看整个的暂存列表git stash save : 来查看对应的所有的修改，这样就可以非常方便的找到最好的实现方案git stash show -p stash@{1} : 不输入对应的 stash@{} 内容则将最近的 stash 与当前分支做比较，如果加了则用指定的暂存 Git stash apply 的时候，报错 : 12error Your local changes to the follow files would be overwritten by merge: xxxxPlease commit your changes or stash them before you merge . 可以先add 修改的文件，然后再apply 12git add test.txtgit stash apply","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"rebase","slug":"rebase","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/rebase/"},{"name":"merge","slug":"merge","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/merge/"}]},{"title":"Emacs 学习之旅","slug":"生活总结/emacs-learning-way","date":"2017-03-01T22:38:00.000Z","updated":"2020-01-07T07:14:32.152Z","comments":true,"path":"2017/03/02/生活总结/emacs-learning-way/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2017/03/02/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/emacs-learning-way/","excerpt":"","text":"Emacs 的使用过程，就像是程序员的生涯一样——路漫漫其修远兮，吾将上下而求索。 万物始于 Emacs最早知道 Emacs 是从编辑器的圣战开始的，即编辑器之神——Vi，和神的编辑器——Emacs。两个编辑器在经历了几十年的战争之后，仍然是编辑世界不可超越的高峰。 但在一开始，我选择的是 Vi，因为在 *nix 中，都是有安装的，在服务器编辑文件——即使是很大的文件，Vi 也可以非常轻易的打开编辑，在一段时间内，我几乎是跪着使用 Vi 的。 后来随着想用的功能越来越多，而 Vi 只能做为编辑器使用，再加上被一些大神安利，我就选择尝试使用 Emacs 来装逼记笔记。于是下载了当时正流行的 Purcell 大神的配置，并开始尝试使用，不过没过多少就放弃了。 期间阅读了许多入门学习的内容，对 Emacs 有了一个大概的了解。 推荐阅读内容： 《一年成为 Emacs 高手（像神一样使用编辑器）》 Prelude 入门级 Emacs 配置 Purcell 大神的配置 Emacs 始于 OrgEmacs 学习的无疾而终，让我的装逼大计一度沉沦。直到我开始尝试利用 Org-mode 进行博客写和作日程管理，阅读了一些文章之后，才真正开始了 Emacs 的学习苦旅。 如果说 Emacs 是神的编辑器的话， Org 可能是神器之中的神器，随着对 Org 的学习和使用，我从最初的装逼，到后来的逼格提升真正开始利用Emacs，都是因为Org-mode 。 推荐阅读内容： mudan 大神的 Org-mode 入门级手册 mudan 大神的漂亮的文言文排版 Tisoga 大神的 Org + GitHub 的博客教学 终于 Spacemacs 的战争从最开始的学习，到现在已经习惯于使用 Emacs ，主要因为其确实是可以提升效率的，当然这里要把配置时间拿走。虽然开始使用的原因有所不同，但是大家最后的目标却都是一样的——即提高工作（学习）效率。 但是经过了 Emacs 几次强行配置之后，学习了一些 Emacs 的填坑方案。 后来加入了一个 Emacs 的微信群——毫不夸张的说，这是我加入过的群里面质量最高的，学习效果最好的，而且所有的成员都自发的维护群里的闲聊问题，每一次讨论都是提问解决和讨论的过程。 在偶然的一次机会，被安利了一把 Spacemacs，Vi 的操作加上 Emacs 的扩展，不要太吸引人！ 推荐关注的大神： Hick 高质量 Emacs 微信群群主，应该也是发起人，水的人自觉加入闲聊群，是我所有技术相关微信群中质量最高的。 子龙山人 Spacemacs Rock 视频作者，我的配置里抄的最多的就是这位大神的。 DarkSun 黑日大神，大神的文章非常多，而且质量都非常高，还维护着一个 Emacs 推广相关的项目，多读读，可以找到一些自己需要的配置。 tumashu 天然二呆，呆神，之前看到呆神在闲聊群里水，后来又看到呆神在帮忙解决问题，好奇的关注了一下 GitHub ，才发现，竟然这几个好用的 package 都是呆神写的，而且呆神竟然不是程序员靠程序吃饭！ 大神太多了，不一一推荐，如果需要，可以联系 Hick 加一下群，就都有了。 再推荐一下中文的 Emacs 论坛，可以提问，也可以讨论： Emacs China 一堆大神在维护的论坛，经常看看，非常好用。 我的 Emacs 配置初始为了更好管理配置，推荐使用 .spacemacs.d 文件夹进行管理配置，而不是使用 .spacemacs 文件。也为了方便后续的扩展。 可能会遇到的问题如果是在 Windows 下使用，需要注意几个问题： 推荐用编译版本，或者用官方网站加部分 .dll 文件来解决 使用过程中，为了配置的时候好用——更适合 Linux，我是使用在环境变量中增加默认的 HOME 的方案，也可以使用其它方法 直接下载就可以使用，维护的是 develop 分支，后续会慢慢往 master 分支中合并 最终选择在几经周折之后，最后还是选择自己从头开始配置一套 .emacs.d ，主要是因为以下几个问题： 随着使用的人越来越多，维护的东西也越来越多，项目太大了 最终希望的是使用 Vi 的快捷键方案，可以使用 evil-mode 来替代 个人使用的特性话的内容太多，完全引用项目不如借鉴项目的配置方案 我的 emacs 原生配置 我的博客地址如果想看我的博客，可以访问：hugo博客 或者 hexo博客。","categories":[{"name":"生活总结","slug":"生活总结","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"},{"name":"Emacs","slug":"生活总结/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/Emacs/"}],"tags":[{"name":"Emacs","slug":"Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/Emacs/"},{"name":"org mode","slug":"org-mode","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/org-mode/"}]},{"title":"MySQL 数据库设置远程权限","slug":"后台技术/mysql/mysql-authority-config","date":"2016-04-29T02:55:00.000Z","updated":"2020-01-06T03:39:33.122Z","comments":true,"path":"2016/04/29/后台技术/mysql/mysql-authority-config/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2016/04/29/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/mysql/mysql-authority-config/","excerpt":"","text":"设置访问单个数据库权限 设置用户名为 root，密码为空，可以访问数据库 test 1mysql&gt;grant all privileges on test.* to 'root'@'%'; 设置访问全部数据库权限 设置用户名为 root，密码为空，可以访问所有数据库 1mysql&gt;grant all privileges on *.* to 'root'@'%'; 设置指定用户名访问权限 指定用户名为 liuhui，密码为空，可以访问所有数据库 1mysql&gt;grant all privileges on *.* to 'liuhui'@'%'; 设置密码访问权限 设置用户名为 liuhui，密码为 liuhui，可以访问所有数据库 1mysql&gt;grant all privileges on *.* to 'liuhui'@'%' IDENTIFIED BY 'liuhui'; 设置指定可访问主机权限 设置用户名为 liuhui，密码为 liuhui，可以访问所有数据库，只有 10.1.1.1 这台机器有权限访问 1mysql&gt;grant all privileges on *.* to 'liuhui'@'10.1.1.1'; 设置对应的密码级别 参数解释 validate_password_dictionary_file: 用于难密码强度的字典文件路径 validate_password_length: 密码最小长度，参数默认为 8， validate_password_mixed_case_count: 密码至少要包含的小写字母个数和大写字母个数 validate_password_number_count: 密码至少要包含的数字个数 validate_password_policy: 密码强度难 0/LOW 1/MEDIUM 2/STRONG validate_password_special_char_count: 密码至少要包含的特殊字符数 1mysql&gt;show variables like 'validate_password%';","categories":[{"name":"后台技术","slug":"后台技术","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/"},{"name":"MySQL","slug":"后台技术/MySQL","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%90%8E%E5%8F%B0%E6%8A%80%E6%9C%AF/MySQL/"}],"tags":[{"name":"grant privileges","slug":"grant-privileges","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/grant-privileges/"}]},{"title":"Git 基础命令","slug":"工具环境/git/git-basic-command","date":"2016-04-26T23:02:00.000Z","updated":"2020-01-07T09:30:06.382Z","comments":true,"path":"2016/04/27/工具环境/git/git-basic-command/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2016/04/27/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-basic-command/","excerpt":"","text":"新建代码库123456#在当前目录新建一个 git 代码库$ git init#新建一个目录，将其初始化为 git 代码库$ git init [project-name]#下载一个项目和它的整个代码历史$ git clone [url] 全局配置和项目配置git 的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） 1234567#显示当前 git 配置$ git config --list#编辑 git 配置文件$ git config -e [--global]#设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 增加/删除文件123456789101112#添加指定文件到暂存区$ git add [file1] [file2] ...#添加指定目录到暂存区，包括子目录$ git add [dir]#添加当前目录的所有文件到暂存区$ git add .#删除工作区文件，并且将这次删除放入到暂存区$ git rm [file1] [file2] ...#停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]#改名文件，并将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交12345678910111213#提交暂存区到仓库区$ git commit -m [message]#提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]#提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a#提交时显示所有 diff 信息$ git commit -v#使用一次新的 commit,替代上一次提交#如果代码没有变化，则用来改写上一次的 commit 的提交信息$ git commit --amend -m [message]#重做上一次 commit, 并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支1234567891011121314151617181920212223242526272829303132333435#列出所有本地分支$ git branch#列出所有远程分支$ git branch -r#列出所有本地分支和远程分支$ git branch -a#新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 将原有分支名称 old branch name 修改为 new namegit branch -m &lt;old branch name&gt; &lt;new name&gt;# 修改当前分支名称为 new namegit branch -m &lt;new name&gt;#新建一个分支，并切换到当该分支$ git checkout -b [branch-name]#新建一个分支，指向指定 commit$ git branch [branch] [commit]#新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]#切换到指定分支，并更新工作区$ git checkout [branch-name]#建立追踪关系，在现有分支与指定的远程分支之前$ git branch --set-upstream [branch] [remote-branch]#合并指定分支到当前分支$ git merge [branch]#选择一个 commit,合并进当前分支$ git cherry-pick [commit]#删除分支$ git branch -d [branch-name]#删除远程分支$ git push origin --delete [branch-name]#删除与远程分支关联$ git branch -dr [remote/branch]#删除远程分支 2$ git branch -r -d origin/[branch-name]$ git push origin :[branch-name] 标签1234567891011121314151617181920212223242526#列出所有 tag$ git tag#在当前 commit，新建一个 tag$ git tag [tag]#在指定 commit，新建一个 tag$ git tag [tag] [commit]#删除本地 tag$ git tag -d [tag]#删除远程 tag$ git push origin :refs/tags/[tagName]#查看 tag 信息$ git show [tag]#提交指定的 tag$ git push [remote] [tag]#提交所有 tag$ git push [remote] --tags#新建一个分支，指向某个 tag$ git checkout -b [branch] [tag]#重命名 tag$ git tag -f [new-tagName] [old-tagName]$ git tag -d [old-tagName]#将本地 tag 推送到远程$ git push origin :refs/tags/[old-tagName]$ git push --tags# 拉取 taggit fatch origin tag tag_name 查看信息123456789101112131415161718192021222324252627282930313233#显示所有变更的文件$ git status#显示当前分支的版本历史$ git log#显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat#显示某个 commit 之后的所有变动，每个 commit 占据一行$ git log [tag] HEAD --pretty=format:%s#显示某个 commit 之后的所有变动，其“提交说明”必须符合条件$ git log [tag] HEAD --grep feature#显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]#显示指定文件相关的每一次 diff$ git log -p [file]#显示指定文件是什么人在什么时间修改过$ git blame [file]#显示暂存区与工作区的差异$ git diff#显示暂存区和上一个 commit 的差异$ git diff --cached [file]#显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD#显示两次提交之间的差异$ git diff [first-branch] ... [second-branch]#显示某次提交的元数据和内容变化$ git show [commit]#显示某次提交发生的变化的文件$ git show --name-only [commit]#显示某次提交时，某个文件的内容$ git show [commit]:[filename]#显示当前分支的最近几次提交$ git reflog 远程同步12345678910111213141516#下载运程仓库的所有变动$ git fetch [remote]#显示所有远程分支$ git remote -v#显示某个远程仓库的信息$ git remote show [remote]#增加一个新的远程仓库，并命名$ git remote add [shortname] [url]#取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]#上传本地指定分支到远程仓库$ git push [remote] [branch]#强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force#推送所有分支到远程仓库$ git push [remote] --all 修改远程仓库地址1234# 先删除远程分支地址$ git remote rm origin# 然后重新增加远程分支地址$ git remote add origin [url] 撤销12345678910111213141516171819#恢复暂存区的指定文件到工作区$ git checkout [file]#恢复某个 commit 的指定文件到工作区$ git checkout [commit] [file]#恢复上一个 commit 的所有文件到工作区$ git checkout .#重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]#重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard#重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]#重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit]#重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]#新建一个 commit, 用来撤销指定 commit#后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 其它12#生成一个可供发布的压缩包$ git archive git 提升内容 储藏暂存内容 12345678# 想要切换分支，但是还不想要提交之前的工作，可以储存修改信息，将新的储藏推送到栈上$ git stash / git stash save# 在这时，能够轻易的切换分支并在其他地方工作，你的修改被存储在栈上。要查看储藏的东西，可以使用 git stash list$ git stash list# 可以将刚刚的储藏重新加载回来$ git stash apply# 也可以通过储藏的序号进行加载$ git stash apply stash@&#123;1&#125; 核武器级选项 filter-branch 1234567891011121314# 从每一个提交移除一个文件：指 git add . 的内容完整的上传到仓库，但是当希望开源这个内容的时候，需要移除一些无用的文件，--tre-filter 选项在的每一个提交后，运行指定的命令，然后重新提交结果。$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD# 使一个子目录做为新的根目录：假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk/tags 等等）。如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做，再在新项目根目录是 trunk 子目录且 Git 会自动移除所有不影响子目录的提交。$ git filter-branch --subdirectory-filter trunk HEAD# 在开始工作时忘记运行 git config 来设置你的名字与邮箱地址，或者你想要开源一个项目，并且修改所有你的工作邮箱地址为你的个人邮箱地址。任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。需要小心的是只修改你自己的邮箱地址，所以使用 --commit-filter 来修改：$ git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME = \"scott Chacon\"; GIT_AUTHOR_EMAIL = \"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/Git/"},{"name":"command","slug":"command","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/command/"}]},{"title":"Emacs 快捷键使用","slug":"工具环境/emacs/emacs-keybinds-basic","date":"2016-04-26T03:12:00.000Z","updated":"2020-01-06T02:54:09.332Z","comments":true,"path":"2016/04/26/工具环境/emacs/emacs-keybinds-basic/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2016/04/26/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-keybinds-basic/","excerpt":"","text":"设置 Emacs 的默认编码格式 1(prefer-coding-system &#39;utf-8-unix) 改变文件编码格式 C-x C-m f utf-8-unix RET : 将当前文件转换为 utf-8 编码 C-x C-m c RET C-x C-w RET : 将当前文件另存为指定编码 查看需要的库文件 M-: image-library-alist RET : 查看 emacs 支持需要的库文件 123456789101112((xpm \"libxpm.dll\" \"xpm4.dll\" \"libXpm-nox4.dll\")(png \"libpng16.dll\" \"libpng16-16.dll\")(tiff \"libtiff-5.dll\" \"libtiff3.dll\" \"libtiff.dll\")(jpeg \"libjpeg-9.dll\")(gif \"libgif-7.dll\")(svg \"librsvg-2-2.dll\")(gdk-pixbuf \"libgdk_pixbuf-2.0-0.dll\")(glib \"libglib-2.0-0.dll\")(gobject \"libgobject-2.0-0.dll\")(gnutls \"libgnutls-28.dll\" \"libgnutls-26.dll\")(libxml2 \"libxml2-2.dll\" \"libxml2.dll\")(zlib \"zlib1.dll\" \"libz-1.dll\"))","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"coding system","slug":"coding-system","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/coding-system/"},{"name":"image library","slug":"image-library","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/image-library/"},{"name":"keybind","slug":"keybind","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/keybind/"}]},{"title":"Git 工作流","slug":"工具环境/git/git-workflow","date":"2016-03-17T00:43:00.000Z","updated":"2020-01-07T09:26:10.807Z","comments":true,"path":"2016/03/17/工具环境/git/git-workflow/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2016/03/17/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/git/git-workflow/","excerpt":"","text":"中心化的工作流优势 首先它让每个开发者都有自己的本地的完整项目副本。隔离的环境使得每个开发都的工作独立于项目的其它修改 —— 他们可以在自己的本地仓库中添加提交，完全无视上游的开发，直到需要的时候。 其次，它让你接触到了 Git 分支和合并模型。Git 分支被设计为故障安全的机制，用来在仓库之间整合代码和共享更改。 如何工作 中心化的工作将中央仓库作为项目中所有修改的唯一入口。默认的开发分支叫做 master，所有的更改都被提交到这个分支。这种工作流不需要 master 之外的其它分支。 开发者将中央仓库克隆到本地后开始工作。在他们的本地项目副本中，他们可以像 SVN 一样修改文件和提交更改；不过这些新的提交被保存在本地 —— 它们和中央仓库完全隔离。这使得开发者可以将和上游的同步推迟到他们方便的时候。 为了向官方项目发布修改，开发者将他们本地 master 分支“推送”到中央仓库。这一步等同于 svn commit，除了 Git 添加的是所有不在中央 master 分支上的提交。 管理冲突 中央仓库代码官方项目，因此它的提交历史应该被视为不可更改的。如果开发者的本地提交和中央仓库分叉了，Git 会拒绝将它们的修改推送上去，因为这会覆盖官方提交。 在开发在提交功能之前，需要 fetch 更新中央提交，在它们之上 rebase 自己的更改。 如果本地修改和上游提交的冲突时，Git 会暂停 rebase 流程，给你机会手工解决这些冲突。Git 很赞的一点是，它将 git status 和 git add 命令同时用来生成提交和解决合并冲突。这使得开发能够轻而易举的管理他们的合并。另外，如果他们改错了什么，Git 能让他们轻易的退出 rebase 过程，然后重试。 例子 项目管理员生成一个空的版本库 1ssh user@host git init --bare /path/to/repo.git 三个人 A, B, C 同时编写同一个项目，需要先在本地创建一个完整的项目副本。 1git clone ssh://user@host/path/to/repo.git 此时，Git 自动添加了一个名为 origin 的运程连接，指向中央仓库，以方便提交。A 可以使用标准 Git 提交流程开发功能：编辑、缓存、提交。 123git statusgit add &lt;some file&gt;git commit 同时，B 也在本地进行自己的开发工作。 A 发布了他们修改 1git push origin master 此时中央仓库会将 master -&gt; origin/master B 试图发布修改 1git push origin master 但是因为 A 已经提交了功能到中央仓库，导致 B 的本地历史和中央仓库分叉，Git 会拒绝本次提交。 B 如果想提交，必须要先 rebase 本地仓库 可以使用 git pull 来拉取并修改， 1git pull --rebase origin master –rebase 命令告诉 Git，在同步中央仓库的修改之后，将 B 的所有提交移到 master 分支的顶端。 如果没有冲突的文件，B 就可以直接进行提交了，但是如果存在冲突，可以根据提示查找冲突的文件，修改之后，可以继续 rebase 操作。 12git add &lt;some-file&gt;git rebase --continue 同样的，如果此时不知道自己做了什么，可以回滚一次操作。 1git rebase --abort 然后再进行 push 就可以提交到中央版本库了。 基于功能人分支的工作流Feature 分支工作流 掌握了中心化工作流的使用姿势，在你的开发流程中添加功能分支是一个简单的方式，来促进协作和开发者之间的交流。这种封装使得多个开发专注自己的功能，而不会打扰主代码库。它还能保证 master 分支永远不会包含损坏的代码，给持续集成环境带来了很大的好处。 封装功能的开发使得 pull request 的使用成为可能，用来启动围绕一个分支的讨论。它给了其他开发者在功能并入主项目之前参与决策的机会。或者，如果你开发功能时卡在一半，可以发起一个 pull request，向同事寻求建议。重点是：pull request 使得团队在评论其他人的工作时，变得非常简单。 如何工作 Feature 分支工作流同样使用中央仓库，master 同样代码官方的项目历史。但是与其直接提交在本地的 master 分支，开发者每次进行新的工作时创建一个新的分支。Feature 分支应该包含描述性的名称，比如 animated-menu-items(菜单项动画)或 issue-*1061。每个分支都应该有一个清晰、高度集中的目的。 Git 在技术上无法区别 master 和功能分支，所以开发者可以在 feature 分支上编辑、缓存、提交，就和中心化工作流中一样。 此外，feature 分支可以被推送到中央仓库。这使得你和其他开发者共享这个功能，而又不改变官方代码。既然 master 只是一个“特殊”的分支，在中央仓库中储存多个 feature 分支不会引出什么问题。当然，这也是备份每个开发者本地提交的好办法。 Pull Request 除了隔离功能开发之外，分支使得通过 pull request 讨论修改成为可能。一旦有人完成了一个功能，他们不会立即将它并入 master。他们将 feature 分支推送到中央服务器上，发布一个 pull request，请求将他们的修改并入 master。这给了其他开发者在修改并入主代码库之前审查的机会。 代码审查是 pull request 的主要好处，但他们事实上被设计成为讨论代码的一般场所。你可以把 pull request 看作是专注某个分支的讨论版。也就是说他们可以用于开发流程之前。比如，一个开发者在某个功能上需要帮助，他只需要发起一个 pull request。感兴趣的小伙伴会自动收到通知，看到相关提交中的问题。 一旦 pull request 被接受了，发布功能的行为和中心化的工作流是一样的。首先，确定你本地的 master 和上游的 master 已经同步。然后，将 feature 分支并入 master 已经同步。然后可以将 feature 分支并入 master，将更新的 master 推送回中央仓库。 Gitflow 工作流 GitFlow 工作流围绕项目发布定义了一个严格的分支模型。有些地方比功能分支工作流更复杂，为管理大型项目提供了框架。 和功能分支工作流相比，这种工作流没有增加任何新的概念或命令。它给不同的分支指定了特定的角色，定义它们应该如何、什么时候交流。除了功能分支之外，它还为准备发布、维护发布、记录发布分别使用了单独的分支。当然，还能享受到功能分支工作流带来的所有好处：pull request、隔离实验和更高效的协作。 如何工作 GitFlow 工作流仍然使用中央仓库作为开发者沟通的中心。和其它工作流一样，开发者在本地工作，将分支推送到中央仓库。唯一的区别在于项目的分支结构。 历史分支 和单独的 master 分支不同，这种工作流使用两个分支来记录项目历史。master 分支储存官方发布历史，develop 分支用来整合功能分支。同时，这还方便了在 master 分支上给所有提交打上版本号标签。 工作流剩下的部分围绕这两个分支的差别展开。 功能分支 每个新功能都放置在自己的分支中，可以在备份/协作时推送到中央仓库。但是与其合并到 master，功能分支将开发分支作为父分支。当一个功能完成时，它将被合并回 develop。功能永远不应该支持在 master 上交互。 功能分支加上 develop 分支就是我们之前据说的功能分支工作流。 发布分支 一旦 develop 分支的新功能足够发布，你可以从 develop 分支 fork 一个发布分支。这个分支的创建开始了下个发布周期，只有和发布相关的任务应该在这个分支进行，如修复 bug、生成文档等。一旦准备好发布，发布分支将合并进 master，打上版本号的标签。另外，它也应该合并回 develop，后者可能在发布启动之后有了新的进展。 使用一个专门的分支来准备发布确保一个团队完善当前的发布，其它团队可以继续开发下一个发布的功能。它还建立了清晰的开发阶段。 通常约定： 从 develop 创建分支 合并进 master 分支 命名规范 release-* 或者 release/* 维护分支 维护或者“紧急修复”分支用来快速给产品发布打上补丁。这是唯一可以从 master 上 fork 的分支。一旦修复完成了，它应该被并入 master 和 develop 分支，master 应该打上更新的版本号的标签。 有一个专门的 bug 修复开发线使得团队能够处理 issue，而不打断其它工作流或是要等到下一个发布周期。你可以将维护分支看作在 master 分支上工作的临时发布分支。 例子创建一个开发分支 为默认的 master 分支创建一个互补的 develop 分支。最简单的办法是在本地创建一个空的 develop 分支，将他推送到服务器上： 12git branch developgit push -u origin develop 这个分支将会包含项目中所有的历史，而 master 将包含不完全的版本。其他开发者应该将中央仓库克隆到本地，创建一个分支来追踪 develop 分支： 12git clone http://xxx/xx/repo.gitgit checkout -b develop origin/develop 开始了新的功能 当两个人都需要在不同分支上开始工作，即为自己的功能创建单独的分支。且他们的分支都是基于 develop 而不是 master： 1git checkout -b some-feature develop 他们都使用“编辑、缓存、提交”的一般约定来向功能分支添加提交： 123git statusgit add &lt;some-file&gt;git commit 完成功能 添加了一些提交后，可以使用 pull request，现在正是发起的好时机，请求将新功能并入 develop 分支。否则可以先并入本地的 develop 分支，推送到中央仓库： 12345git pull origin developgit checkout developgit merge some-featuregit pushgit branch -d some-feature 第一个命令在尝试并入功能分支之前确保 develop 分支已经是最新的。注意，功能绝不该直接并入 master。冲突的处理方式和中心化工作流相同。 发布新功能 当另外的开发人员，仍在他自己的分支上工作时，开始准备项目的第一个官方发布。和开发功能一样，新建一个分支来封装发布的准备工作。这也正是发布的版本号创建的第一步： 1git checkout -b release-0.1 develop 这个分支用来整理提交，充分测试，更新文档，为即将到来的发布做各种准备。它就像是一个专门用来完善发布的功能分支。 一旦发布准备稳妥，即将其并入 master 和 develop，然后删除发布分支。合并回 develop 很重要，因为可能已经有关键的更新添加到发布分支上，而开发新功能需要用到它们。同样的，如果团队重视代码审查，现在将是发起 pull request 的完美时机。 1234567git checkout mastergit merge release-0.1git pushgit checkout developgit merge release-0.1git pushgit branch -d release-0.1 发布分支是功能开发（develop）分支和公开发布（master）之间的过渡阶段。不论什么时候，将提交并入 msater 时，你应该为提交打上方便引用的标签： 12git tag -a 0.1 -m \"Initial public release\" mastergit push --tags Git 提供了许多钩子，即仓库中特定事件发生时被执行的脚本。当你向中央仓库推送 master 分支或者标签时，你可以配置一个钩子来自动化构建公开发布。 终端用户发现一个 Bug 正式发布之后，两个开发一起为下一个发布开发功能。这时，一个终端用户开了一个 issue 抱怨说当前发布中存在一个 Bug。为了解决这个 bug，先从 master 创建一个维护分支，用几个提交修复这个 issue，然后直接合并回 master。 12345git checkout -b issue*001 master##Fix the buggit checkout mastergit merge issue-*001git push 和发布分支一样，维护分支包含了 develop 中需要的重要更新，因此需要执行同样的合并。接下来，可以删除这个分支： 1234git checkout developgit merge issue-*001git pushgit branch -d issue-*001 各分支的意义 feature (多个) 主要是自己玩了，差不多的时候要合并回 develop 去。不与 master 交互。 develop (同时间一个) 主要是和 feature 以及 release 交互 release (同时间一个) 总是基于 develop，最后又合并回 develop。当然对应的 tag 要合并到 master 分支，生命周期短，仅是为了发布程序 hotfix (同一时间一个) 总是基于 master，并最后合并到 master 和 develop。生命同期较短，用来修复 bug 或小粒度修改发布 master (仅一个) 关联 tag 和发布 模型中各个模块内容的使用 在这个模型中，master 和 develop 都具有象征意义。master 分支上的代码总是稳定的 (stable build)，随时可以发布出去。develop 上的代码总是从 feature 上合并过来的，可以进行 Nightly Builds，但不直接在 develop 上进行开发。当 develop 上的 featur 足够多以致于可以进行新版本的发布时，可以创建 release 分支。 release 分支基于 develop，进行委阴简单的修改后就被合并到 master，并打上 tag，表示可以发布了。紧接着 release 将被合并到 develop；此时 Develop 可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并，这步完成后就删除 release 分支 当从已发布版本中发现 bug 要修复时，就应用到 hotfix 分支了。hotfix 基于 master 分支，完成 bug 修复或者紧急修改后，要 merge 回 master，打上一个新的 tag，并 merge 回 develop，删除 hotfix 分支。 由此可见 release 和 hotfix 的生命周期都较短，而 master 和 develop 虽然总是存在，但去不常使用。","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Git","slug":"工具环境/Git","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Git/"}],"tags":[{"name":"workflow","slug":"workflow","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/workflow/"},{"name":"工作流","slug":"工作流","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"Graphviz dot 笔记","slug":"工具环境/emacs/emacs-graphviz-dot","date":"2016-01-07T23:39:00.000Z","updated":"2020-01-07T00:35:54.208Z","comments":true,"path":"2016/01/08/工具环境/emacs/emacs-graphviz-dot/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2016/01/08/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/emacs/emacs-graphviz-dot/","excerpt":"","text":"Dot 生成图的默认命令dot -T&lt;type&gt; -o &lt;outfile&gt; &lt;infile.dot&gt; dot 可以替换为circo等其他算法，详细见命令的选择章节。 输入文件是 &lt;infile.dot&gt; ，生成的格式由 指定，生成的文件是 。其中 -T 包括： 12345678910-Tps (PostScript)-Tsvg -Tsvgz (Structured Vector Graphics)-Tfig (XFIG graphics)-Tmif (FrameMaker graphics)-Thpgl (HP pen plotters)-Tpcl (Laserjet printers)-Tpng -Tgif (bitmap graphics)-Tdia (GTK+ based diagrams)-Timap (imagemap files for httpd servers for each node or edge that has a non-null \"href\" attribute.)-Tcmapx (client-side imagemap for use in html and xhtml) rankrank 约束了子图的节点位置，有向图中，一个箭头的指向，带有级别，一般是尾端高于尖端，即 a-&gt;b a 的级别要高于 b 的级别。 same : 所有节点在同一级别的节点处 min : 所有节点在最小级别节点处 source : 所有节点在最低级别，且只有子图属性为 source 或者 min 的时候，才能使用同样的级别 max : 类似于 source sink : 类似于 source NOTE: 最低级别，可以是 最上 、 最下 、 最左 、 最右 rankdir TB : top-to-bottom LR : left-to-right BT : bottom-to-top RL : right-to-left dot 线条12345splines &#x3D; ortho #直角拆线splines &#x3D; spline #曲线（不遮挡）splines &#x3D; cuvved #曲线（可遮挡）splines &#x3D; line #直线（可遮挡）splines &#x3D; polyline #直线（不遮挡） 命令的选择 命令 介绍 dot 渲染图具有明确的方向性 neato 图缺乏方向性 twopi 图采用放射性布局 circo 图采用环形布局 fdp 图缺乏方向性 sfdp 用来渲染大型图，且图片缺乏方向性 静默执行代码1(setq org-confirm-babel-evaluate nil) ;;执行静默语句块 dot 实例 绘制流程图: 12345678digraph structs &#123;node[shape&#x3D;record]struct1 [label&#x3D;&quot;&lt;f0&gt; left|&lt;f1&gt; mid\\ dle|&lt;f2&gt; right&quot;];struct2 [label&#x3D;&quot;&#123;&lt;f0&gt; one|&lt;f1&gt; two\\n\\n\\n&#125;&quot; shape&#x3D;Mrecord];struct3 [label&#x3D;&quot;hello\\nworld |&#123; b |&#123;c|&lt;here&gt; d|e&#125;| f&#125;| g | h&quot;];struct1:f1 -&gt; struct2:f0;struct1:f0 -&gt; struct3:f1;&#125; 12345678910111213141516171819202122232425262728293031323334353637 digraph g &#123; size&#x3D;&quot;8,6&quot; ratio&#x3D;expand edge [dir&#x3D;both] plcnet [shape&#x3D;box, label&#x3D;&quot;plc network&quot;] subgraph cluster_wrapline &#123; label&#x3D;&quot;wrapline control system&quot; color&#x3D;purple subgraph &#123; rank&#x3D;same exec sharedmem [style&#x3D;filled, fillcolor&#x3D;lightgrey, shape&#x3D;box] &#125; edge[style&#x3D;dotted, dir&#x3D;none] exec -&gt; opserver exec -&gt; db plc -&gt; exec edge [style&#x3D;line, dir&#x3D;both] exec -&gt; sharedmem sharedmem -&gt; db plc -&gt; sharedmem sharedmem -&gt; opserver &#125; plcnet -&gt; plc [constraint&#x3D;false] millwide [shape&#x3D;box, label&#x3D;&quot;millwide system&quot;] db -&gt; millwide subgraph cluster_opclients &#123; color&#x3D;blue label&#x3D;&quot;operator client&quot; rankdir&#x3D;lr labelloc&#x3D;b node[label&#x3D;client] opserver -&gt; client1 opserver -&gt; client2 opserver -&gt; client3 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344digraph G &#123;rankdir&#x3D;LRnode [shape&#x3D;plaintext]a [label&#x3D;&lt;&lt;TABLE BORDER&#x3D;&quot;0&quot; CELLBORDER&#x3D;&quot;1&quot; CELLSPACING&#x3D;&quot;0&quot;&gt;&lt;TR&gt;&lt;TD ROWSPAN&#x3D;&quot;3&quot; BGCOLOR&#x3D;&quot;yellow&quot;&gt;class&lt;&#x2F;TD&gt;&lt;&#x2F;TR&gt;&lt;TR&gt;&lt;TD PORT&#x3D;&quot;here&quot; BGCOLOR&#x3D;&quot;lightblue&quot;&gt;qualifier&lt;&#x2F;TD&gt;&lt;&#x2F;TR&gt;&lt;&#x2F;TABLE&gt;&gt;]b [shape&#x3D;ellipse style&#x3D;filledlabel&#x3D;&lt;&lt;TABLE BGCOLOR&#x3D;&quot;bisque&quot;&gt;&lt;TR&gt;&lt;TD COLSPAN&#x3D;&quot;3&quot;&gt;elephant&lt;&#x2F;TD&gt;&lt;TD ROWSPAN&#x3D;&quot;2&quot; BGCOLOR&#x3D;&quot;chartreuse&quot;VALIGN&#x3D;&quot;bottom&quot; ALIGN&#x3D;&quot;right&quot;&gt;two&lt;&#x2F;TD&gt; &lt;&#x2F;TR&gt;&lt;TR&gt;&lt;TD COLSPAN&#x3D;&quot;2&quot; ROWSPAN&#x3D;&quot;2&quot;&gt;&lt;TABLE BGCOLOR&#x3D;&quot;grey&quot;&gt;&lt;TR&gt; &lt;TD&gt;corn&lt;&#x2F;TD&gt; &lt;&#x2F;TR&gt;&lt;TR&gt; &lt;TD BGCOLOR&#x3D;&quot;yellow&quot;&gt;c&lt;&#x2F;TD&gt; &lt;&#x2F;TR&gt;&lt;TR&gt; &lt;TD&gt;f&lt;&#x2F;TD&gt; &lt;&#x2F;TR&gt;&lt;&#x2F;TABLE&gt; &lt;&#x2F;TD&gt;&lt;TD BGCOLOR&#x3D;&quot;white&quot;&gt;penguin&lt;&#x2F;TD&gt;&lt;&#x2F;TR&gt;&lt;TR&gt; &lt;TD COLSPAN&#x3D;&quot;2&quot; BORDER&#x3D;&quot;4&quot; ALIGN&#x3D;&quot;right&quot; PORT&#x3D;&quot;there&quot;&gt;4&lt;&#x2F;TD&gt; &lt;&#x2F;TR&gt;&lt;&#x2F;TABLE&gt;&gt;]c [label&#x3D;&lt;long line 1&lt;BR&#x2F;&gt;line 2&lt;BR ALIGN&#x3D;&quot;LEFT&quot;&#x2F;&gt;line 3&lt;BR ALIGN&#x3D;&quot;RIGHT&quot;&#x2F;&gt;&gt;]subgraph &#123; rank&#x3D;same b c &#125;a:here -&gt; b:there [dir&#x3D;both arrowtail &#x3D; diamond]c -&gt; bd [shape&#x3D;triangle]d -&gt; c [label&#x3D;&lt;&lt;TABLE&gt;&lt;TR&gt;&lt;TD BGCOLOR&#x3D;&quot;red&quot; WIDTH&#x3D;&quot;10&quot;&gt; &lt;&#x2F;TD&gt;&lt;TD&gt;Edge labels&lt;BR&#x2F;&gt;also&lt;&#x2F;TD&gt;&lt;TD BGCOLOR&#x3D;&quot;blue&quot; WIDTH&#x3D;&quot;10&quot;&gt; &lt;&#x2F;TD&gt;&lt;&#x2F;TR&gt;&lt;&#x2F;TABLE&gt;&gt;]&#125;","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"Emacs","slug":"工具环境/Emacs","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/Emacs/"}],"tags":[{"name":"dot","slug":"dot","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/dot/"},{"name":"graphviz","slug":"graphviz","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/graphviz/"}]},{"title":"CSS  语法入门","slug":"前端开发/css-learning-notes","date":"2016-01-05T22:45:00.000Z","updated":"2020-01-06T09:03:08.610Z","comments":true,"path":"2016/01/06/前端开发/css-learning-notes/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2016/01/06/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/css-learning-notes/","excerpt":"","text":"CSS 是前端开发的基础。CSS 規則由兩個主要的部分構成:選擇器，以及一條或者多條聲明。CSS 是前端开发的基础，主要由两个部分构成： 选择器 声明，可以是单条，也可以是多条 1selector &#123; declaration1; declaration2; ... declarationN;&#125; 选择器通常是 HTML 中的元素。每条声明都是由一个属性和一个值构成，属性是希望设置的样式、属性，每个属性都有一个值，并用冒号分开。 1selector &#123;property: value&#125; 下面代码的作用是将 h1 元素内的文字的颜色定义为红色，同时将字体的大小设置为 14 像素。 在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。 1h1 &#123;color : red; font-size: 14px;&#125; 如果值是多个词组，可以给值增加引号。 1p &#123; font-family: \"sans serif\";&#125; 如果林定义不止一个声明，则需要用分号将每个声明隔开。 下面的示例是将段落的字体定义为红色且居中。 虽然最后一个属性是不需要增加分号的，但是为了以后修改，最好在每条属性后面都增加分号分隔符。 12345p &#123; text-align: center; color: black; font-family: arial;&#125; 子元素总是继承你元素的属性。 123body &#123; font-family: Vrdana, sans-serif;&#125; 这样，在 body 属性下的元素：p, td, ul, ol, li, dl, dt, dd 等都会继承 body 中定义的字体，同样继承来的值也可以进行重写。 12body &#123; font-family: Vrdana;&#125;p &#123; font-family: Times;&#125; 选择器、派生选择器：通过依据元素位置的上下文件关系来定义的样式。 1234li strong &#123; font-style: italic; font-weight: normal;&#125; ID 选择器：可以为标有特定 ID 的元素指定样式。 1#red &#123; color: red;&#125; ID 选择器也可以和派生选择器一起使用。 12345#sidebar p&#123; font-style: italic; text-align: right; margin-top: 0.5em;&#125; 单独选择器：可以单独发挥作用的选择器。 1234#sidebar &#123; border: 1px dotted #000; padding: 10px;&#125; 类选择器：以一个点号作为开头。 1.center &#123; text-align: center;&#125; 也可以用作派生选择器上。 1234.fancy td &#123; color: #f60; background: #666;&#125; 元素也可以基于它们的类而被选择。 1234td.fancy &#123; color: #f60; background: #666;&#125; 上面的两个示例中，第一个是类名为 fancy 的元素内容属性设置，下面的则是指 &lt;td class=&#39;fancy&#39;&gt; 的元素的属性设置。 选择器 描述 [attribut] 用于选取带有指定属性的元素 [attribut=value] 用于选取带有指定属性和值的元素 [attribut~=value] 用于选取属性值中包含指定词条的元素 [attribut&vert;=value] 用于选取带有以指定开头的属性值的元素，该值必须是整个单词 [attribut^=value] 匹配属性值以指定值开头的每个元素 [attribut$=value] 匹配属性值以指定值结尾的每个元素 [attribut*=value] 匹配属性值中包含指定值的每个元素 CSS 允许应用纯色做为背景，也允许使用背景图片创建一个繁杂的效果。 可以使用 background-color 指定背景色，这个属性接受任务合法的颜色值。可以利用这个将背景色配置为灰色。background-color 是不能被继承的。 123p &#123; background-color: gray;&#125;p &#123; background-color: gray; padding:20px;&#125;","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"css","slug":"前端开发/css","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/css/"}]},{"title":"gcc/g++ 命令","slug":"工具环境/gcc-g++-command","date":"2015-12-22T18:26:00.000Z","updated":"2020-01-07T02:32:03.105Z","comments":true,"path":"2015/12/23/工具环境/gcc-g++-command/","link":"","permalink":"https://www.zucchiniy.cn/hexo-blog/2015/12/23/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/gcc-g++-command/","excerpt":"","text":"gcc -E sourcefile.c : -E，只执行到预编译，直接输出预编译结果 gcc -S sourcefile.c : -S，只执行到源代码到汇编代码的转换，输出汇编代码 gcc -c sourcefile.c : -c，只执行到编译，输出目标文件 gcc (-E/-S/-c) sourcefile.c -o output-file : -o，指定输出文件名，可以使用以上三种标签中的一种。 -o 参数可以被省略，这种情况下编译器按以下默认名方式输出: -E 预编译结果将被输出到标准输出端口-S 生成名为 sourcefile.s 的汇编文件-c 生成名为 sourcefile.o 的目标文件 无标签的时候，生成名为 a.out 的可执行文件 gcc -g sourcefile.c-g 生成供调用的可执行文件，可以在 gdb 中运行。由于文件中包含了调试信息，因此运行效率很低，且文件也大了不少。这里可以用 strip 把文件中的 debug 信息删除。 strip a.out gcc -s sourcefile.c-s 直接生成与运用 strip 同样的效果的可执行文件gcc -O sourcefile.c-O 编译器对代码进行自动化编译，输出效率更高的可执行文件&lt;p class=&quot;verse&quot;&gt; -O2 可以跟上数字表示优化等级 gcc -O2 sourcefile.c 数字越大越加优化。但是也会有出 bug 的风险&lt;br /&gt; &lt;/p&gt;gcc -Wall sourcefile.c-W 在编译中开启一些额外的警告信息。-Wall，将所有的警告信息全开。gcc sourcefile.c -L/path/to/lib -lxxx -l/path/to/include - -l 指定所使用到的函数库，本例中是尝试链接名为 libxxx.a 的函数库 - -L 指定函数库所在的文件，本例中链接器会尝试搜索/path/to/lib 文件夹 - -I 指定文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include 文件夹","categories":[{"name":"工具环境","slug":"工具环境","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/"},{"name":"GCC","slug":"工具环境/GCC","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/categories/%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83/GCC/"}],"tags":[{"name":"gcc","slug":"gcc","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/gcc/"},{"name":"g++","slug":"g","permalink":"https://www.zucchiniy.cn/hexo-blog/blog/tags/g/"}]}]}